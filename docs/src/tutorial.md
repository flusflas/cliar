# Tutorial

## Hello World

In Cliar, commandline interfaces are represented by Python classes subclassed from `Cliar`. Cliar turns the class methods into commands and their params into args.

Let's create a simple CLI that says "Hello World!" when you call `hello` command:

```python
from cliar import Cliar


class Greeter(Cliar):           # Define a regular Python class
    def hello(self):            # and a regular method,
        print('Hello World!')   # which implements the business logic.


if __name__ == '__main__':
    greeter = Greeter()         # Create an instance of the class
    greeter.parse()             # and run its `parse` method.
```

Save this code into `greeter.py` and run it with Python:

```shell
$ python greeter.py hello
Hello World!
```

And here it is: your first CLI created with Cliar! That was easy, wasn't it?

Let's enhance `hello` method to shout the greeting loud if `--shout` flag is passed:

```python
    def hello(self, shout=False):
        greeting = 'Hello World!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

Try running `greeter.py` with and without the newly defined flag:

```shell
$ python greeter.py hello --shout
HELLO WORLD!

$ python greeter.py hello -s    # Short version works, too!
HELLO WORLD!

$ python greeter.py hello
Hello World!
```

Cliar did a few things for us here:

-   `shout` is an optional param, so it was converted into an optional flag
-   since `shout` default value is `False`, Cliar inferred its type as `bool`, so we can use it as such inside `hello` body
-   not only was `--shout` flag generated from the eponymous `shout` param, but a short version `-s` was also generated


## Hello {user}

Ok, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to `hello`:

```python
    def hello(self, name, shout=False):
        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

Try it:

```shell
$ python greeter.py hello John
Hello John!

$ python greeter.py hello John --shout
HELLO JOHN!

$ python greeter.py hello -s John
HELLO JOHN!

$ python greeter.py hello
usage: greeter.py hello [-h] [-s] name
greeter.py hello: error: the following arguments are required: name
```


## Help Messages

If you run `greeter.py` with `--help` or `-h` flag, you'll see the help message generated by Cliar:

```shell
$ python greeter.py --help
usage: greeter.py [-h] {hello} ...

optional arguments:
  -h, --help  show this help message and exit

commands:
  {hello}     Available commands:
    hello

$ python greeter.py hello --help
usage: greeter.py hello [-h] [-s] name

positional arguments:
  name

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout
```

Although it does show some useful information, it's still quite poor: there's no app or command description or information about `--shout` or `name` arguments.

First, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those:

```python
class Greeter(Cliar):
    '''Greeter app created with in Cliar.'''

    def hello(self, name, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

Try calling the help messages now:

```shell
$ python greeter.py -h
usage: greeter.py [-h] {hello} ...

Greeter app created with in Cliar.

optional arguments:
  -h, --help  show this help message and exit

commands:
  {hello}     Available commands:
    hello     Say hello to {name}.

$ python greeter.py hello -h
usage: greeter.py hello [-h] [-s] name

Say hello.

positional arguments:
  name

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout
```

That's much better! Now, let's add descriptions for `--shout` and `name` arguments.


## Argument Descriptions

To add description for arguments, use `set_help` decorator:

```python
from cliar import Cliar, set_help

...

    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

The decorator takes a mapping from param names to help messages.

Call the help message for `hello` command:

```shell
$ python greeter.py hello -h
usage: greeter.py hello [-h] [-s] name

Say hello.

positional arguments:
  name         The greetee

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout  Set to shout the greeting
```


## Metavars

*Metavar* is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for `name` param the metavar is called `name`:

```shell
$ python greeter.py hello -h
usage: greeter.py hello [-h] [-s] name

Say hello.

positional arguments:
  name         The greetee

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout  Set to shout the greeting
```

Let's change it to `NAME`, just so it's more visible in the line. To do that, use `set_metavars` decorator:

```python
from cliar import Cliar, set_help, set_metavars

...

    @set_metavars({'name': 'NAME'})
    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

The decorator takes a mapping from param names to metavars.

Call the help message for `hello`:

```shell
usage: greeter.py hello [-h] [-s] NAME

Say hello.

positional arguments:
  NAME         The greetee

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout  Set to shout the greeting
```


## Type Casting

Cliar can cast the types of args on the fly. To enable type casting, add a type hint to the param or set a default value for it.

To showcase this feature, let's add a flag `-n` that will tell how many times we want the greeting to appear on the screen:

```python
    @set_metavars({'name': 'NAME'})
    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, n=1, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        for _ in range(n):  # Cliar guarantees `n` is an integer
            if shout:
                print(greeting.upper())
            else:
                print(greeting)
```

Note that inside `hello` code, we never convert `n` to integer or wrap anything in `try` blocks. Cliar cares about all that, allowing the programmer to focus on the business logic.

Let's call `hello` with the new flag:

```shell
$ python greeter.py hello John -n 2
Hello John!
Hello John!
```

Let's see what happens if we pass a non-integer value to `-n`:

```shell
$ python greeter.py hello John -n foo
usage: greeter.py hello [-h] [-n N] [-s] NAME
greeter.py hello: error: argument -n/--n: invalid int value: 'foo'
```

Because the passed value is invalid, Cliar stopped the execution before it even reached `hello`. This behavior guarantees that your code is always executed with valid input.

!!! hint

    You can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using `open` as the param type:

    ```python
    def read_from_file(input_file: open):
        lines = input_file.readlines()
    ```

    If you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed.

!!! note

    If no type is set for a param, `str` is implied by default.


## Custom Arg Names

In the previous example, `-n` is a rather poor name for a flag. Something more descriptive, like `--repeat` would be better.

Cliar lets you set the names of the args without changing the handler code at all. Just use `set_arg_map` decorator:

```python
from cliar import Cliar, set_help, set_metavars, set_arg_map

...

    @set_arg_map({'n': 'repeat'})
    @set_metavars({'name': 'NAME'})
    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, n=1, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        for _ in range(n):
            if shout:
                print(greeting.upper())
            else:
                print(greeting)
```

Now you can use `--repeat` or `-r` instead of `-n`:

```shell
$ python greeter.py hello John --repeat 2
Hello John!
Hello John!

$ python greeter.py hello John -r 2
Hello John!
Hello John!
```

!!! hint

    This decorator lets you use Python's reserved words as arg names: `for`, `with`, etc.

!!! note

    By default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name: `name` is turned into `--name`, and `upper_limit` into `--upper-limit`; the first letter is used as a short option: `-n` for `--name`, `-u-` for `--upper-limit`.
