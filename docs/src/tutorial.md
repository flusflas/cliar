# Tutorial

Download the complete sample app: [greeter.py](assets/greeter.py)

## Hello World

In Cliar, commandline interfaces are represented by Python classes subclassed from `Cliar`. Cliar turns the class methods into commands and their params into args.

Let's create a simple CLI that says "Hello World!" when you call `hello` command:

```python
from cliar import Cliar


class Greeter(Cliar):           # Define a regular Python class
    def hello(self):            # and a regular method,
        print('Hello World!')   # which implements the business logic.


if __name__ == '__main__':
    Greeter().parse()           # Instantiate the class and run `parse` method.
```

Save this code into `greeter.py` and run it with Python:

```shell
$ python greeter.py hello
Hello World!
```

And here it is: your first CLI created with Cliar! That was easy, wasn't it?

## Optional Flags

Let's enhance `hello` method to shout the greeting loud if `--shout` flag is passed:

```python
    def hello(self, shout=False):
        greeting = 'Hello World!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

Try running `greeter.py` with and without the newly defined flag:

```shell
$ python greeter.py hello --shout
HELLO WORLD!

$ python greeter.py hello -s    # Short version works, too!
HELLO WORLD!

$ python greeter.py hello
Hello World!
```

Cliar did a few things for us here:

-   `shout` is an optional param, so it was converted into an optional flag
-   since `shout` default value is `False`, Cliar inferred its type as `bool`, so we can use it as such inside `hello` body
-   not only was `--shout` flag generated from the eponymous `shout` param, but a short version `-s` was also generated


## Positional Arguments

Ok, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to `hello`:

```python
    def hello(self, name, shout=False):
        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

Try it:

```shell
$ python greeter.py hello John
Hello John!

$ python greeter.py hello John --shout
HELLO JOHN!

$ python greeter.py hello -s John
HELLO JOHN!

$ python greeter.py hello
usage: greeter.py hello [-h] [-s] name
greeter.py hello: error: the following arguments are required: name
```


## Help Messages

If you run `greeter.py` with `--help` or `-h` flag, you'll see the help message generated by Cliar:

```shell
$ python greeter.py --help
usage: greeter.py [-h] {hello} ...

optional arguments:
  -h, --help  show this help message and exit

commands:
  {hello}     Available commands:
    hello

$ python greeter.py hello --help
usage: greeter.py hello [-h] [-s] name

positional arguments:
  name

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout
```

Although it does show some useful information, it's still quite poor: there's no app or command description or information about `--shout` or `name` arguments.

First, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those:

```python
class Greeter(Cliar):
    '''Greeter app created with in Cliar.'''

    def hello(self, name, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

Try calling the help messages now:

```shell
$ python greeter.py -h
usage: greeter.py [-h] {hello} ...

Greeter app created with in Cliar.

optional arguments:
  -h, --help  show this help message and exit

commands:
  {hello}     Available commands:
    hello     Say hello to {name}.

$ python greeter.py hello -h
usage: greeter.py hello [-h] [-s] name

Say hello.

positional arguments:
  name

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout
```

That's much better! Now, let's add descriptions for `--shout` and `name` arguments.

!!! hint

    `self._parser` is an [`ArgumentParser`](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser) instance, so you can use all its methods and attributes, like `print_help` or `usage`.


## Argument Descriptions

To add description for arguments, use `set_help` decorator:

```python
from cliar import Cliar, set_help

...

    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

The decorator takes a mapping from param names to help messages.

Call the help message for `hello` command:

```shell
$ python greeter.py hello -h
usage: greeter.py hello [-h] [-s] name

Say hello.

positional arguments:
  name         The greetee

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout  Set to shout the greeting
```

To show default values for optional params, add `show_defaults = True` to `set_help`:

```python
...
    @set_help(
        {'name': 'The greetee', 'shout': 'Set to shout the greeting'},
        show_defaults = True
    )
    def hello(self, name, shout=False):
...
```

Call help again to see the default value:

```shell
$ python greeter.py hello -h
usage: greeter.py hello [-h] [-s] name

Say hello.

positional arguments:
  name         The greetee

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout  Set to shout the greeting (default: False)
```


## Metavars

*Metavar* is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for `name` param the metavar is called `name`:

```shell
$ python greeter.py hello -h
usage: greeter.py hello [-h] [-s] name

Say hello.

positional arguments:
  name         The greetee

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout  Set to shout the greeting
```

Let's change it to `NAME`, just so it's more visible in the line. To do that, use `set_metavars` decorator:

```python
from cliar import Cliar, set_help, set_metavars

...

    @set_metavars({'name': 'NAME'})
    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        if shout:
            print(greeting.upper())
        else:
            print(greeting)
```

The decorator takes a mapping from param names to metavars.

Call the help message for `hello`:

```shell
usage: greeter.py hello [-h] [-s] NAME

Say hello.

positional arguments:
  NAME         The greetee

optional arguments:
  -h, --help   show this help message and exit
  -s, --shout  Set to shout the greeting
```


## Type Casting

Cliar can cast the types of args on the fly. To enable type casting, add a type hint to the param or set a default value for it.

To showcase this feature, let's add a flag `-n` that will tell how many times we want the greeting to appear on the screen:

```python
    @set_metavars({'name': 'NAME'})
    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, n=1, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        for _ in range(n):  # Cliar guarantees `n` is an integer
            if shout:
                print(greeting.upper())
            else:
                print(greeting)
```

Note that inside `hello` code, we never convert `n` to integer or wrap anything in `try` blocks. Cliar cares about all that, allowing the programmer to focus on the business logic.

Let's call `hello` with the new flag:

```shell
$ python greeter.py hello John -n 2
Hello John!
Hello John!
```

Let's see what happens if we pass a non-integer value to `-n`:

```shell
$ python greeter.py hello John -n foo
usage: greeter.py hello [-h] [-n N] [-s] NAME
greeter.py hello: error: argument -n/--n: invalid int value: 'foo'
```

Because the passed value is invalid, Cliar stopped the execution before it even reached `hello`. This behavior guarantees that your code is always executed with valid input.

!!! hint

    You can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using `open` as the param type:

        def read_from_file(input_file: open):
            lines = input_file.readlines()

    If you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed.

!!! note

    If no type is set for a param, `str` is implied by default. So, `name: str` is the same as just `name`.


## Argument Names

By default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name: `name` is turned into `--name`, and `upper_limit` into `--upper-limit`; the first letter is used as a short option: `-n` for `--name`, `-u` for `--upper-limit`.

In the previous example, `-n` is a rather poor name for a flag. Something more descriptive, like `--repeat` would be better.

Cliar lets you set the names of the args without changing the handler code at all. Just use `set_arg_map` decorator:

```python
from cliar import Cliar, set_help, set_metavars, set_arg_map

...

    @set_arg_map({'n': 'repeat'})
    @set_metavars({'name': 'NAME'})
    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, n=1, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        for _ in range(n):
            if shout:
                print(greeting.upper())
            else:
                print(greeting)
```

Now you can use `--repeat` or `-r` instead of `-n`:

```shell
$ python greeter.py hello John --repeat 2
Hello John!
Hello John!

$ python greeter.py hello John -r 2
Hello John!
Hello John!
```

!!! hint

    This decorator lets you use Python's reserved words as arg names: `--for`, `--with`, etc.

You can also override argument short names specifically. This is useful when you have several arguments that start with the same letter, which creates a conflict between short arg names:

```python
from cliar import Cliar, set_help, set_metavars, set_arg_map, set_sharg_map

...

    @set_arg_map({'n': 'repeat'})
    @set_sharg_map({'n': 'n'})
    @set_metavars({'name': 'NAME'})
    @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'})
    def hello(self, name, n=1, shout=False):
        '''Say hello.'''

        greeting = f'Hello {name}!'

        for _ in range(n):
            if shout:
                print(greeting.upper())
            else:
                print(greeting)
```

Now you can use `-n` instead of `-r`:

```shell
$ python greeter.py hello John --repeat 2
Hello John!
Hello John!

$ python greeter.py hello John -n 2
Hello John!
Hello John!
```

To disable short argument variant entirely, set the short arg name to `None`: ```@set_sharg_map({'argname': None})```.


## More Commands

Adding more commands to the CLI simply means adding more methods to the CLI class:

```python
class Greeter(Cliar):
    def goodbye(self, name):        # Just define another method
        '''Say goodbye'''           # to add another command to the CLI.

        print(f'Goodbye {name}!')

    @set_arg_map({'n': 'repeat'})
    ...
```

With this code addition, you can call `goodbye` command:

```shell
$ python greeter.py goodbye Mary
Goodbye Mary!
```

## Nested Commands

You can have any level of nested commands by adding Cliar CLIs as class attributes.

For example, let's add a `utils` subcommand with its own `time` subcommand that has `now` command:

```python
class Time(Cliar):
    def now(self, utc=False):
        if utc:
            print(f'UTC time is {datetime.utcnow().ctime()}')
        else:
            print(f'Local time is {datetime.now().ctime()}')

class Utils(Cliar):
    time = Time

class Greeter(Cliar):
    '''Greeter app created with in Cliar.'''

    utils = Utils

    def _root(self, version=False):
        ...
```

You can now call `now` command:

```shell
$ python greeter.py utils time now
Local time is Sun Jul 21 15:25:52 2019

$ python greeter.py utils time now --utc
UTC time is Sun Jul 21 11:25:57 2019
```


## Command Aliases

Imagine you want to let user to call the same command with different keywords. For example, we want to ship our greeter app to Spain and let the users call `greeter.py mientras` as well as `greeter.py goodbye`.

The keywords that point to the same command are called *aliases*. To add aliases to a command, use `add_aliases` decorator:

```python
from cliar import Cliar, set_help, set_metavars, set_arg_map, add_aliases

...

    @add_aliases(['mientras', 'пока'])  # Yes you can use non-Latin characters!
    def goodbye(self, name):
        '''Say goodbye'''

        print(f'Goodbye {name}!')
```

And now you can call `goodbye` command with its aliases:

```shell
$ python greeter.py mientras Maria
Goodbye Maria!

$ python greeter.py пока Маша
Goodbye Маша!
```


## Command Names

By default, Cliar names CLI commands after the handler methods on the CLI class. To override this behavior and set a custom command name, use `set_name` decorator:

```python
from cliar import Cliar, set_help, set_metavars, set_arg_map, add_aliases, set_name


class Greeter(Cliar):
    '''Greeter app created with in Cliar.'''

    @set_name('factorial')                  # Name the command `factorial`
    def calculate_factorial(self, n: int):  # because `calculate_factorial`
        '''Calculate factorial'''           # is too long for CLI.

        print(f'n! = {factorial(n)}')

    @add_aliases(['mientras', 'пока'])
    ...
```

Now `calculate_factorial` is associated with, and only with, `factorial` command:

```shell
$ python greeter.py factorial 4
n! = 24

$ poetry run python greeter.py calculate_factorial 4
usage: greeter.py [-h] {factorial,goodbye,mientras,пока,hello} ...
greeter.py: error: argument command: invalid choice: 'calculate_factorial' (choose from 'factorial', 'goodbye', 'mientras', 'пока', 'hello')
```


## Ignore Methods

By default, Cliar converts all non-static and non-class methods of the `Cliar` subclass into CLI commands.

There are two ways to tell Cliar *not* to convert a method into a command: start its name with an underscore or use `ignore` decorator:

```python
from math import factorial, tau, pi

from cliar import Cliar, set_help, set_metavars, set_arg_map, add_aliases, set_name, ignore


class Greeter(Cliar):
    '''Greeter app created with in Cliar.'''

    def _get_tau_value(self):
        return tau

    @ignore
    def get_pi_value(self):
        return pi

    def constants(self):
        print(f'τ = {self._get_tau_value()}')
        print(f'π = {self.get_pi_value()}')

    ...
```

Only `constants` method will be exposed as a CLI command:

```shell
$ poetry run python greeter.py constants
τ = 6.283185307179586
π = 3.141592653589793

$ poetry run python greeter.py get-pi-value
usage: greeter.py [-h] {factorial,constants,goodbye,mientras,пока,hello} ...
greeter.py: error: argument command: invalid choice: 'get-pi-value' (choose from 'factorial', 'constants', 'goodbye', 'mientras', 'пока', 'hello')
```


# Root Command

So far, we've defined args and flags only for commands, e.g. `hello` and `goodbye`. But some flags are commonly defined for the entire script rather for a particular command, for example `--version`. Also, sometimes you don't need commands at all: if there's only only action that your CLI does, defining a single command is redundant as the script name will suffice:

```shell
$ python say_hello.py           # We want this
$ python say_hello.py say_hello # rather than this.
```

In other words, we need a way to define a nameless command that runs when you run the script itself without any command.

Cliar lets you define such command by defining a special `_root` method:

```python
class Greeter(Cliar):
    '''Greeter app created with in Cliar.'''

    def _root(self, version=False):
        if version:
            print('Greeter 1.0.0.')
        else:
            print('Welcome to Greeter!')
    ...
```

If you run `greeter.py` with `--version` or `-v` flag, you'll see its version. If you call `greeter.py` without any flags or commands, you'll see a welcome message:

```shell
$ python greeter.py
Welcome to Greeter!

$ python greeter.py --version
Greeter 1.0.0.
```
