{
    "docs": [
        {
            "location": "/",
            "text": "Cliar\n\u00b6\n\n\nCliar is yet another Python package to create commandline interfaces. It focuses on simplicity, extensibility, and testability:\n\n\n\n\nCreating a CLI is as simple as subclassing \ncliar.Cliar\n.\n\n\nExtending a CLI is as simple as extending the class via inheritance.\n\n\nTesting a CLI is as simple as unittesting the class's methods.\n\n\n\n\nCliar's mission is to let the programmer focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in the programmer's way, so it provides the means to customize the generated CLI.\n\n\nInstallation\n\u00b6\n\n\n$ pip install cliar\n\n\n\n\n\nCliar runs on Python 3.6+ on Windows, Linux, and Mac. There are no dependencies outside Python's standard library.\n\n\nComparison of Python CLI Packages\n\u00b6\n\n\n\n\n\n\n\n\nName\n\n\nDSL-based\n\n\nCasts arg types\n\n\nExtensible\n\n\nTestable without shell exec\n\n\nHas pun in name\n\n\n\n\n\n\n\n\n\n\nClick\n\n\n\u274c\n\n\n\u274c\n\n\n\u2714, in third-party modules\n\n\n\u274c\n\n\n\u2714\n\n\n\n\n\n\ndocopt\n\n\n\u2714\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\n\n\n\nargparse\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\n\n\n\nCliar\n\n\n\u274c\n\n\n\u2714\n\n\n\u2714, \nin\n third-party modules and \nwith\n third-party modules\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\nBasic Usage\n\u00b6\n\n\nLet's create a commandline calculator that adds two real numbers with Cliar:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n\n\n\n\nclass\n \nCalculator\n(\nCliar\n):\n\n\n'''Calculator app.'''\n\n\n    \ndef\n \nadd\n(\nself\n,\n \nx\n:\n \nfloat\n,\n \ny\n:\n \nfloat\n):\n\n    \n'''Add two real numbers.'''\n\n\n        \nprint\n(\nf\n'The sum of {x} and {y} is {x+y}.'\n)\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nCalculator\n()\n.\nparse\n()\n\n\n\n\n\n\nSave this code to \ncalc.py\n and run it with different inputs:\n\n\n\n\n\n\nValid input:\n\n\n$ python run calc.py add \n12\n \n34\n\nThe sum of \n12\n.0 and \n34\n.0 is \n46\n.0.\n\n\n\n\n\n\n\n\n\nInvalid input:\n\n\n$ python run calc.py foo bar\nusage: calc.py add \n[\n-h\n]\n x y\ncalc.py add: error: argument x: invalid float value: \n'foo'\n\n\n\n\n\n\n\n\n\n\nGet help:\n\n\n$ python run calc.py -h\nusage: calc.py \n[\n-h\n]\n \n{\nadd\n}\n ...\n\nCalculator app.\n\noptional arguments:\n-h, --help  show this \nhelp\n message and \nexit\n\n\ncommands:\n\n{\nadd\n}\n       Available commands:\n    add       Add two real numbers.\n\n\n\n\n\n\n\n\n\nGet help for a specific command:\n\n\n$ python calc.py add -h\nusage: calc.py add \n[\n-h\n]\n x y\n\nAdd two real numbers.\n\npositional arguments:\nx\ny\n\noptional arguments:\n-h, --help  show this \nhelp\n message and \nexit\n\n\n\n\n\n\n\n\n\n\nThere are a few things to note here:\n\n\n\n\n\n\nIt's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar.\n\n\n\n\n\n\nThe \nadd\n method is converted into \nadd\n command, and its positional params are converted into positional commandline args.\n\n\n\n\n\n\nWe don't convert \nx\n or \ny\n to \nfloat\n or handle any potential conversion errors in the \nadd\n body. Instead, we treat \nx\n and \ny\n as if they were already guaranteed to be floats. That's because Cliar does the validation and conversion for us, using the information from \nadd\n's type hints. Note how invalid input doesn't even reach your code.\n\n\n\n\n\n\nThe \n--help\n and \n-h\n flags are added automatically and the help messages are generated from the docstrings.\n\n\n\n\n\n\nBut wait! There's more!\n\u00b6\n\n\nCliar lets you customize your CLI in many ways! \nRead the tutorial\n to learn all Cliar's powers.\n\n\nHappy hacking!",
            "title": "Home"
        },
        {
            "location": "/#cliar",
            "text": "Cliar is yet another Python package to create commandline interfaces. It focuses on simplicity, extensibility, and testability:   Creating a CLI is as simple as subclassing  cliar.Cliar .  Extending a CLI is as simple as extending the class via inheritance.  Testing a CLI is as simple as unittesting the class's methods.   Cliar's mission is to let the programmer focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in the programmer's way, so it provides the means to customize the generated CLI.",
            "title": "Cliar"
        },
        {
            "location": "/#installation",
            "text": "$ pip install cliar  Cliar runs on Python 3.6+ on Windows, Linux, and Mac. There are no dependencies outside Python's standard library.",
            "title": "Installation"
        },
        {
            "location": "/#comparison-of-python-cli-packages",
            "text": "Name  DSL-based  Casts arg types  Extensible  Testable without shell exec  Has pun in name      Click  \u274c  \u274c  \u2714, in third-party modules  \u274c  \u2714    docopt  \u2714  \u274c  \u274c  \u274c  \u274c    argparse  \u274c  \u274c  \u274c  \u274c  \u274c    Cliar  \u274c  \u2714  \u2714,  in  third-party modules and  with  third-party modules  \u2714  \u2714",
            "title": "Comparison of Python CLI Packages"
        },
        {
            "location": "/#basic-usage",
            "text": "Let's create a commandline calculator that adds two real numbers with Cliar:  from   cliar   import   Cliar  class   Calculator ( Cliar ):  '''Calculator app.''' \n\n     def   add ( self ,   x :   float ,   y :   float ): \n     '''Add two real numbers.''' \n\n         print ( f 'The sum of {x} and {y} is {x+y}.' )  if   __name__   ==   '__main__' : \n     Calculator () . parse ()   Save this code to  calc.py  and run it with different inputs:    Valid input:  $ python run calc.py add  12   34 \nThe sum of  12 .0 and  34 .0 is  46 .0.    Invalid input:  $ python run calc.py foo bar\nusage: calc.py add  [ -h ]  x y\ncalc.py add: error: argument x: invalid float value:  'foo'     Get help:  $ python run calc.py -h\nusage: calc.py  [ -h ]   { add }  ...\n\nCalculator app.\n\noptional arguments:\n-h, --help  show this  help  message and  exit \n\ncommands: { add }        Available commands:\n    add       Add two real numbers.    Get help for a specific command:  $ python calc.py add -h\nusage: calc.py add  [ -h ]  x y\n\nAdd two real numbers.\n\npositional arguments:\nx\ny\n\noptional arguments:\n-h, --help  show this  help  message and  exit     There are a few things to note here:    It's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar.    The  add  method is converted into  add  command, and its positional params are converted into positional commandline args.    We don't convert  x  or  y  to  float  or handle any potential conversion errors in the  add  body. Instead, we treat  x  and  y  as if they were already guaranteed to be floats. That's because Cliar does the validation and conversion for us, using the information from  add 's type hints. Note how invalid input doesn't even reach your code.    The  --help  and  -h  flags are added automatically and the help messages are generated from the docstrings.",
            "title": "Basic Usage"
        },
        {
            "location": "/#but-wait-theres-more",
            "text": "Cliar lets you customize your CLI in many ways!  Read the tutorial  to learn all Cliar's powers.  Happy hacking!",
            "title": "But wait! There's more!"
        },
        {
            "location": "/tutorial/",
            "text": "Tutorial\n\u00b6\n\n\nDownload the complete sample app: \ngreeter.py\n\n\nHello World\n\u00b6\n\n\nIn Cliar, commandline interfaces are represented by Python classes subclassed from \nCliar\n. Cliar turns the class methods into commands and their params into args.\n\n\nLet's create a simple CLI that says \"Hello World!\" when you call \nhello\n command:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n\n\n\n\nclass\n \nGreeter\n(\nCliar\n):\n           \n# Define a regular Python class\n\n    \ndef\n \nhello\n(\nself\n):\n            \n# and a regular method,\n\n        \nprint\n(\n'Hello World!'\n)\n   \n# which implements the business logic.\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \ngreeter\n \n=\n \nGreeter\n()\n         \n# Create an instance of the class\n\n    \ngreeter\n.\nparse\n()\n             \n# and run its `parse` method.\n\n\n\n\n\n\nSave this code into \ngreeter.py\n and run it with Python:\n\n\n$ python greeter.py hello\nHello World!\n\n\n\n\n\nAnd here it is: your first CLI created with Cliar! That was easy, wasn't it?\n\n\nLet's enhance \nhello\n method to shout the greeting loud if \n--shout\n flag is passed:\n\n\n    \ndef\n \nhello\n(\nself\n,\n \nshout\n=\nFalse\n):\n\n        \ngreeting\n \n=\n \n'Hello World!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nTry running \ngreeter.py\n with and without the newly defined flag:\n\n\n$ python greeter.py hello --shout\nHELLO WORLD!\n\n$ python greeter.py hello -s    \n# Short version works, too!\n\nHELLO WORLD!\n\n$ python greeter.py hello\nHello World!\n\n\n\n\n\nCliar did a few things for us here:\n\n\n\n\nshout\n is an optional param, so it was converted into an optional flag\n\n\nsince \nshout\n default value is \nFalse\n, Cliar inferred its type as \nbool\n, so we can use it as such inside \nhello\n body\n\n\nnot only was \n--shout\n flag generated from the eponymous \nshout\n param, but a short version \n-s\n was also generated\n\n\n\n\nHello {user}\n\u00b6\n\n\nOk, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to \nhello\n:\n\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nTry it:\n\n\n$ python greeter.py hello John\nHello John!\n\n$ python greeter.py hello John --shout\nHELLO JOHN!\n\n$ python greeter.py hello -s John\nHELLO JOHN!\n\n$ python greeter.py hello\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\ngreeter.py hello: error: the following arguments are required: name\n\n\n\n\n\nHelp Messages\n\u00b6\n\n\nIf you run \ngreeter.py\n with \n--help\n or \n-h\n flag, you'll see the help message generated by Cliar:\n\n\n$ python greeter.py --help\nusage: greeter.py \n[\n-h\n]\n \n{\nhello\n}\n ...\n\noptional arguments:\n  -h, --help  show this \nhelp\n message and \nexit\n\n\ncommands:\n  \n{\nhello\n}\n     Available commands:\n    hello\n\n$ python greeter.py hello --help\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout\n\n\n\n\n\nAlthough it does show some useful information, it's still quite poor: there's no app or command description or information about \n--shout\n or \nname\n arguments.\n\n\nFirst, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those:\n\n\nclass\n \nGreeter\n(\nCliar\n):\n\n    \n'''Greeter app created with in Cliar.'''\n\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nTry calling the help messages now:\n\n\n$ python greeter.py -h\nusage: greeter.py \n[\n-h\n]\n \n{\nhello\n}\n ...\n\nGreeter app created with in Cliar.\n\noptional arguments:\n  -h, --help  show this \nhelp\n message and \nexit\n\n\ncommands:\n  \n{\nhello\n}\n     Available commands:\n    hello     Say hello to \n{\nname\n}\n.\n\n$ python greeter.py hello -h\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\nSay hello.\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout\n\n\n\n\n\nThat's much better! Now, let's add descriptions for \n--shout\n and \nname\n arguments.\n\n\n\n\nHint\n\n\nYou can print the help message by calling \nself._parser.print_help()\n.\n\n\n\n\nArgument Descriptions\n\u00b6\n\n\nTo add description for arguments, use \nset_help\n decorator:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n\n\n\n...\n\n\n    \n@set_help\n({\n'name'\n:\n \n'The greetee'\n,\n \n'shout'\n:\n \n'Set to shout the greeting'\n})\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nThe decorator takes a mapping from param names to help messages.\n\n\nCall the help message for \nhello\n command:\n\n\n$ python greeter.py hello -h\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout  Set to shout the greeting\n\n\n\n\n\nMetavars\n\u00b6\n\n\nMetavar\n is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for \nname\n param the metavar is called \nname\n:\n\n\n$ python greeter.py hello -h\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout  Set to shout the greeting\n\n\n\n\n\nLet's change it to \nNAME\n, just so it's more visible in the line. To do that, use \nset_metavars\n decorator:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n,\n \nset_metavars\n\n\n\n...\n\n\n    \n@set_metavars\n({\n'name'\n:\n \n'NAME'\n})\n\n    \n@set_help\n({\n'name'\n:\n \n'The greetee'\n,\n \n'shout'\n:\n \n'Set to shout the greeting'\n})\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nThe decorator takes a mapping from param names to metavars.\n\n\nCall the help message for \nhello\n:\n\n\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n NAME\n\nSay hello.\n\npositional arguments:\n  NAME         The greetee\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout  Set to shout the greeting\n\n\n\n\n\nType Casting\n\u00b6\n\n\nCliar can cast the types of args on the fly. To enable type casting, add a type hint to the param or set a default value for it.\n\n\nTo showcase this feature, let's add a flag \n-n\n that will tell how many times we want the greeting to appear on the screen:\n\n\n    \n@set_metavars\n({\n'name'\n:\n \n'NAME'\n})\n\n    \n@set_help\n({\n'name'\n:\n \n'The greetee'\n,\n \n'shout'\n:\n \n'Set to shout the greeting'\n})\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nn\n=\n1\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nfor\n \n_\n \nin\n \nrange\n(\nn\n):\n  \n# Cliar guarantees `n` is an integer\n\n            \nif\n \nshout\n:\n\n                \nprint\n(\ngreeting\n.\nupper\n())\n\n            \nelse\n:\n\n                \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nNote that inside \nhello\n code, we never convert \nn\n to integer or wrap anything in \ntry\n blocks. Cliar cares about all that, allowing the programmer to focus on the business logic.\n\n\nLet's call \nhello\n with the new flag:\n\n\n$ python greeter.py hello John -n \n2\n\nHello John!\nHello John!\n\n\n\n\n\nLet's see what happens if we pass a non-integer value to \n-n\n:\n\n\n$ python greeter.py hello John -n foo\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-n N\n]\n \n[\n-s\n]\n NAME\ngreeter.py hello: error: argument -n/--n: invalid int value: \n'foo'\n\n\n\n\n\n\nBecause the passed value is invalid, Cliar stopped the execution before it even reached \nhello\n. This behavior guarantees that your code is always executed with valid input.\n\n\n\n\nHint\n\n\nYou can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using \nopen\n as the param type:\n\n\ndef read_from_file(input_file: open):\n    lines = input_file.readlines()\n\n\n\n\n\nIf you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed.\n\n\n\n\n\n\nNote\n\n\nIf no type is set for a param, \nstr\n is implied by default. So, \nname: str\n is the same as just \nname\n.\n\n\n\n\nArgument Names\n\u00b6\n\n\nBy default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name: \nname\n is turned into \n--name\n, and \nupper_limit\n into \n--upper-limit\n; the first letter is used as a short option: \n-n\n for \n--name\n, \n-u-\n for \n--upper-limit\n.\n\n\nIn the previous example, \n-n\n is a rather poor name for a flag. Something more descriptive, like \n--repeat\n would be better.\n\n\nCliar lets you set the names of the args without changing the handler code at all. Just use \nset_arg_map\n decorator:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n,\n \nset_metavars\n,\n \nset_arg_map\n\n\n\n...\n\n\n    \n@set_arg_map\n({\n'n'\n:\n \n'repeat'\n})\n\n    \n@set_metavars\n({\n'name'\n:\n \n'NAME'\n})\n\n    \n@set_help\n({\n'name'\n:\n \n'The greetee'\n,\n \n'shout'\n:\n \n'Set to shout the greeting'\n})\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nn\n=\n1\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nfor\n \n_\n \nin\n \nrange\n(\nn\n):\n\n            \nif\n \nshout\n:\n\n                \nprint\n(\ngreeting\n.\nupper\n())\n\n            \nelse\n:\n\n                \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nNow you can use \n--repeat\n or \n-r\n instead of \n-n\n:\n\n\n$ python greeter.py hello John --repeat \n2\n\nHello John!\nHello John!\n\n$ python greeter.py hello John -r \n2\n\nHello John!\nHello John!\n\n\n\n\n\n\n\nHint\n\n\nThis decorator lets you use Python's reserved words as arg names: \n--for\n, \n--with\n, etc.\n\n\n\n\nMore Commands\n\u00b6\n\n\nAdding more commands to the CLI simply means adding more methods to the CLI class:\n\n\nclass\n \nGreeter\n(\nCliar\n):\n\n    \ndef\n \ngoodbye\n(\nself\n,\n \nname\n):\n        \n# Just define another method\n\n        \n'''Say goodbye'''\n           \n# to add another command to the CLI.\n\n\n        \nprint\n(\nf\n'Goodbye {name}!'\n)\n\n\n    \n@set_arg_map\n({\n'n'\n:\n \n'repeat'\n})\n\n    \n...\n\n\n\n\n\n\nWith this code addition, you can call \ngoodbye\n command:\n\n\n$ python greeter.py goodbye Mary\nGoodbye Mary!\n\n\n\n\n\nCommand Aliases\n\u00b6\n\n\nImagine you want to let user to call the same command with different keywords. For example, we want to ship our greeter app to Spain and let the users call \ngreeter.py mientras\n as well as \ngreeter.py goodbye\n.\n\n\nThe keywords that point to the same command are called \naliases\n. To add aliases to a command, use \nadd_aliases\n decorator:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n,\n \nset_metavars\n,\n \nset_arg_map\n,\n \nadd_aliases\n\n\n\n...\n\n\n    \n@add_aliases\n([\n'mientras'\n,\n \n'\u043f\u043e\u043a\u0430'\n])\n  \n# Yes you can use non-Latin characters!\n\n    \ndef\n \ngoodbye\n(\nself\n,\n \nname\n):\n\n        \n'''Say goodbye'''\n\n\n        \nprint\n(\nf\n'Goodbye {name}!'\n)\n\n\n\n\n\n\nAnd now you can call \ngoodbye\n command with its aliases:\n\n\n$ python greeter.py mientras Maria\nGoodbye Maria!\n\n$ python greeter.py \u043f\u043e\u043a\u0430 \u041c\u0430\u0448\u0430\nGoodbye \u041c\u0430\u0448\u0430!\n\n\n\n\n\nCommand Names\n\u00b6\n\n\nBy default, Cliar names CLI commands after the handler methods on the CLI class. To override this behavior and set a custom command name, use \nset_name\n decorator:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n,\n \nset_metavars\n,\n \nset_arg_map\n,\n \nadd_aliases\n,\n \nset_name\n\n\n\n\nclass\n \nGreeter\n(\nCliar\n):\n\n    \n'''Greeter app created with in Cliar.'''\n\n\n    \n@set_name\n(\n'factorial'\n)\n                  \n# Name the command `factorial`\n\n    \ndef\n \ncalculate_factorial\n(\nself\n,\n \nn\n:\n \nint\n):\n  \n# because `calculate_factorial`\n\n        \n'''Calculate factorial'''\n           \n# is too long for CLI.\n\n\n        \nprint\n(\nf\n'n! = {factorial(n)}'\n)\n\n\n    \n@add_aliases\n([\n'mientras'\n,\n \n'\u043f\u043e\u043a\u0430'\n])\n\n    \n...\n\n\n\n\n\n\nNow \ncalculate_factorial\n is associated with, and only with, \nfactorial\n command:\n\n\n$ python greeter.py factorial \n4\n\nn! \n=\n \n24\n\n\n$ poetry run python greeter.py calculate_factorial \n4\n\nusage: greeter.py \n[\n-h\n]\n \n{\nfactorial,goodbye,mientras,\u043f\u043e\u043a\u0430,hello\n}\n ...\ngreeter.py: error: argument command: invalid choice: \n'calculate_factorial'\n \n(\nchoose from \n'factorial'\n, \n'goodbye'\n, \n'mientras'\n, \n'\u043f\u043e\u043a\u0430'\n, \n'hello'\n)\n\n\n\n\n\n\nIgnore Methods\n\u00b6\n\n\nBy default, Cliar converts all non-static and non-class methods of the \nCliar\n subclass into CLI commands.\n\n\nThere are two ways to tell Cliar \nnot\n to convert a method into a command: start its name with an underscore or use \nignore\n decorator:\n\n\nfrom\n \nmath\n \nimport\n \nfactorial\n,\n \ntau\n,\n \npi\n\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n,\n \nset_metavars\n,\n \nset_arg_map\n,\n \nadd_aliases\n,\n \nset_name\n,\n \nignore\n\n\n\n\nclass\n \nGreeter\n(\nCliar\n):\n\n    \n'''Greeter app created with in Cliar.'''\n\n\n    \ndef\n \n_get_tau_value\n(\nself\n):\n\n        \nreturn\n \ntau\n\n\n    \n@ignore\n\n    \ndef\n \nget_pi_value\n(\nself\n):\n\n        \nreturn\n \npi\n\n\n    \ndef\n \nconstants\n(\nself\n):\n\n        \nprint\n(\nf\n'\u03c4 = {self._get_tau_value()}'\n)\n\n        \nprint\n(\nf\n'\u03c0 = {self.get_pi_value()}'\n)\n\n\n    \n...\n\n\n\n\n\n\nOnly \nconstants\n method will be exposed as a CLI command:\n\n\n$ poetry run python greeter.py constants\n\n\u03c4\n \n=\n \n6\n.283185307179586\n\n\u03c0\n \n=\n \n3\n.141592653589793\n\n$ poetry run python greeter.py get-pi-value\nusage: greeter.py \n[\n-h\n]\n \n{\nfactorial,constants,goodbye,mientras,\u043f\u043e\u043a\u0430,hello\n}\n ...\ngreeter.py: error: argument command: invalid choice: \n'get-pi-value'\n \n(\nchoose from \n'factorial'\n, \n'constants'\n, \n'goodbye'\n, \n'mientras'\n, \n'\u043f\u043e\u043a\u0430'\n, \n'hello'\n)\n\n\n\n\n\n\nRoot Command\n\u00b6\n\n\nSo far, we've defined args and flags only for commands, e.g. \nhello\n and \ngoodbye\n. But some flags are commonly defined for the entire script rather for a particular command, for example \n--version\n. Also, sometimes you don't need commands at all: if there's only only action that your CLI does, defining a single command is redundant as the script name will suffice:\n\n\n$ python say_hello.py           \n# We want this\n\n$ python say_hello.py say_hello \n# rather than this.\n\n\n\n\n\n\nIn other words, we need a way to define a nameless command that runs when you run the script itself without any command.\n\n\nCliar lets you define such command by defining a special \n_root\n method:\n\n\nclass\n \nGreeter\n(\nCliar\n):\n\n    \n'''Greeter app created with in Cliar.'''\n\n\n    \ndef\n \n_root\n(\nself\n,\n \nversion\n=\nFalse\n):\n\n        \nif\n \nversion\n:\n\n            \nprint\n(\nf\n'Greeter 1.0.0.'\n)\n\n        \nelse\n:\n\n            \nprint\n(\n'Welcome to Greeter!'\n)\n\n    \n...\n\n\n\n\n\n\nIf you run \ngreeter.py\n with \n--version\n or \n-v\n flag, you'll see its version. If you call \ngreeter.py\n without any flags or commands, you'll see a welcome message:\n\n\n$ python greeter.py\nWelcome to Greeter!\n\n$ python greeter.py --version\nGreeter \n1\n.0.0.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#tutorial",
            "text": "Download the complete sample app:  greeter.py",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#hello-world",
            "text": "In Cliar, commandline interfaces are represented by Python classes subclassed from  Cliar . Cliar turns the class methods into commands and their params into args.  Let's create a simple CLI that says \"Hello World!\" when you call  hello  command:  from   cliar   import   Cliar  class   Greeter ( Cliar ):             # Define a regular Python class \n     def   hello ( self ):              # and a regular method, \n         print ( 'Hello World!' )     # which implements the business logic.  if   __name__   ==   '__main__' : \n     greeter   =   Greeter ()           # Create an instance of the class \n     greeter . parse ()               # and run its `parse` method.   Save this code into  greeter.py  and run it with Python:  $ python greeter.py hello\nHello World!  And here it is: your first CLI created with Cliar! That was easy, wasn't it?  Let's enhance  hello  method to shout the greeting loud if  --shout  flag is passed:       def   hello ( self ,   shout = False ): \n         greeting   =   'Hello World!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   Try running  greeter.py  with and without the newly defined flag:  $ python greeter.py hello --shout\nHELLO WORLD!\n\n$ python greeter.py hello -s     # Short version works, too! \nHELLO WORLD!\n\n$ python greeter.py hello\nHello World!  Cliar did a few things for us here:   shout  is an optional param, so it was converted into an optional flag  since  shout  default value is  False , Cliar inferred its type as  bool , so we can use it as such inside  hello  body  not only was  --shout  flag generated from the eponymous  shout  param, but a short version  -s  was also generated",
            "title": "Hello World"
        },
        {
            "location": "/tutorial/#hello-user",
            "text": "Ok, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to  hello :       def   hello ( self ,   name ,   shout = False ): \n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   Try it:  $ python greeter.py hello John\nHello John!\n\n$ python greeter.py hello John --shout\nHELLO JOHN!\n\n$ python greeter.py hello -s John\nHELLO JOHN!\n\n$ python greeter.py hello\nusage: greeter.py hello  [ -h ]   [ -s ]  name\ngreeter.py hello: error: the following arguments are required: name",
            "title": "Hello {user}"
        },
        {
            "location": "/tutorial/#help-messages",
            "text": "If you run  greeter.py  with  --help  or  -h  flag, you'll see the help message generated by Cliar:  $ python greeter.py --help\nusage: greeter.py  [ -h ]   { hello }  ...\n\noptional arguments:\n  -h, --help  show this  help  message and  exit \n\ncommands:\n   { hello }      Available commands:\n    hello\n\n$ python greeter.py hello --help\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Although it does show some useful information, it's still quite poor: there's no app or command description or information about  --shout  or  name  arguments.  First, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those:  class   Greeter ( Cliar ): \n     '''Greeter app created with in Cliar.''' \n\n     def   hello ( self ,   name ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   Try calling the help messages now:  $ python greeter.py -h\nusage: greeter.py  [ -h ]   { hello }  ...\n\nGreeter app created with in Cliar.\n\noptional arguments:\n  -h, --help  show this  help  message and  exit \n\ncommands:\n   { hello }      Available commands:\n    hello     Say hello to  { name } .\n\n$ python greeter.py hello -h\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\nSay hello.\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  That's much better! Now, let's add descriptions for  --shout  and  name  arguments.   Hint  You can print the help message by calling  self._parser.print_help() .",
            "title": "Help Messages"
        },
        {
            "location": "/tutorial/#argument-descriptions",
            "text": "To add description for arguments, use  set_help  decorator:  from   cliar   import   Cliar ,   set_help  ... \n\n     @set_help ({ 'name' :   'The greetee' ,   'shout' :   'Set to shout the greeting' }) \n     def   hello ( self ,   name ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   The decorator takes a mapping from param names to help messages.  Call the help message for  hello  command:  $ python greeter.py hello -h\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Set to shout the greeting",
            "title": "Argument Descriptions"
        },
        {
            "location": "/tutorial/#metavars",
            "text": "Metavar  is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for  name  param the metavar is called  name :  $ python greeter.py hello -h\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Set to shout the greeting  Let's change it to  NAME , just so it's more visible in the line. To do that, use  set_metavars  decorator:  from   cliar   import   Cliar ,   set_help ,   set_metavars  ... \n\n     @set_metavars ({ 'name' :   'NAME' }) \n     @set_help ({ 'name' :   'The greetee' ,   'shout' :   'Set to shout the greeting' }) \n     def   hello ( self ,   name ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   The decorator takes a mapping from param names to metavars.  Call the help message for  hello :  usage: greeter.py hello  [ -h ]   [ -s ]  NAME\n\nSay hello.\n\npositional arguments:\n  NAME         The greetee\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Set to shout the greeting",
            "title": "Metavars"
        },
        {
            "location": "/tutorial/#type-casting",
            "text": "Cliar can cast the types of args on the fly. To enable type casting, add a type hint to the param or set a default value for it.  To showcase this feature, let's add a flag  -n  that will tell how many times we want the greeting to appear on the screen:       @set_metavars ({ 'name' :   'NAME' }) \n     @set_help ({ 'name' :   'The greetee' ,   'shout' :   'Set to shout the greeting' }) \n     def   hello ( self ,   name ,   n = 1 ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         for   _   in   range ( n ):    # Cliar guarantees `n` is an integer \n             if   shout : \n                 print ( greeting . upper ()) \n             else : \n                 print ( greeting )   Note that inside  hello  code, we never convert  n  to integer or wrap anything in  try  blocks. Cliar cares about all that, allowing the programmer to focus on the business logic.  Let's call  hello  with the new flag:  $ python greeter.py hello John -n  2 \nHello John!\nHello John!  Let's see what happens if we pass a non-integer value to  -n :  $ python greeter.py hello John -n foo\nusage: greeter.py hello  [ -h ]   [ -n N ]   [ -s ]  NAME\ngreeter.py hello: error: argument -n/--n: invalid int value:  'foo'   Because the passed value is invalid, Cliar stopped the execution before it even reached  hello . This behavior guarantees that your code is always executed with valid input.   Hint  You can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using  open  as the param type:  def read_from_file(input_file: open):\n    lines = input_file.readlines()  If you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed.    Note  If no type is set for a param,  str  is implied by default. So,  name: str  is the same as just  name .",
            "title": "Type Casting"
        },
        {
            "location": "/tutorial/#argument-names",
            "text": "By default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name:  name  is turned into  --name , and  upper_limit  into  --upper-limit ; the first letter is used as a short option:  -n  for  --name ,  -u-  for  --upper-limit .  In the previous example,  -n  is a rather poor name for a flag. Something more descriptive, like  --repeat  would be better.  Cliar lets you set the names of the args without changing the handler code at all. Just use  set_arg_map  decorator:  from   cliar   import   Cliar ,   set_help ,   set_metavars ,   set_arg_map  ... \n\n     @set_arg_map ({ 'n' :   'repeat' }) \n     @set_metavars ({ 'name' :   'NAME' }) \n     @set_help ({ 'name' :   'The greetee' ,   'shout' :   'Set to shout the greeting' }) \n     def   hello ( self ,   name ,   n = 1 ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         for   _   in   range ( n ): \n             if   shout : \n                 print ( greeting . upper ()) \n             else : \n                 print ( greeting )   Now you can use  --repeat  or  -r  instead of  -n :  $ python greeter.py hello John --repeat  2 \nHello John!\nHello John!\n\n$ python greeter.py hello John -r  2 \nHello John!\nHello John!   Hint  This decorator lets you use Python's reserved words as arg names:  --for ,  --with , etc.",
            "title": "Argument Names"
        },
        {
            "location": "/tutorial/#more-commands",
            "text": "Adding more commands to the CLI simply means adding more methods to the CLI class:  class   Greeter ( Cliar ): \n     def   goodbye ( self ,   name ):          # Just define another method \n         '''Say goodbye'''             # to add another command to the CLI. \n\n         print ( f 'Goodbye {name}!' ) \n\n     @set_arg_map ({ 'n' :   'repeat' }) \n     ...   With this code addition, you can call  goodbye  command:  $ python greeter.py goodbye Mary\nGoodbye Mary!",
            "title": "More Commands"
        },
        {
            "location": "/tutorial/#command-aliases",
            "text": "Imagine you want to let user to call the same command with different keywords. For example, we want to ship our greeter app to Spain and let the users call  greeter.py mientras  as well as  greeter.py goodbye .  The keywords that point to the same command are called  aliases . To add aliases to a command, use  add_aliases  decorator:  from   cliar   import   Cliar ,   set_help ,   set_metavars ,   set_arg_map ,   add_aliases  ... \n\n     @add_aliases ([ 'mientras' ,   '\u043f\u043e\u043a\u0430' ])    # Yes you can use non-Latin characters! \n     def   goodbye ( self ,   name ): \n         '''Say goodbye''' \n\n         print ( f 'Goodbye {name}!' )   And now you can call  goodbye  command with its aliases:  $ python greeter.py mientras Maria\nGoodbye Maria!\n\n$ python greeter.py \u043f\u043e\u043a\u0430 \u041c\u0430\u0448\u0430\nGoodbye \u041c\u0430\u0448\u0430!",
            "title": "Command Aliases"
        },
        {
            "location": "/tutorial/#command-names",
            "text": "By default, Cliar names CLI commands after the handler methods on the CLI class. To override this behavior and set a custom command name, use  set_name  decorator:  from   cliar   import   Cliar ,   set_help ,   set_metavars ,   set_arg_map ,   add_aliases ,   set_name  class   Greeter ( Cliar ): \n     '''Greeter app created with in Cliar.''' \n\n     @set_name ( 'factorial' )                    # Name the command `factorial` \n     def   calculate_factorial ( self ,   n :   int ):    # because `calculate_factorial` \n         '''Calculate factorial'''             # is too long for CLI. \n\n         print ( f 'n! = {factorial(n)}' ) \n\n     @add_aliases ([ 'mientras' ,   '\u043f\u043e\u043a\u0430' ]) \n     ...   Now  calculate_factorial  is associated with, and only with,  factorial  command:  $ python greeter.py factorial  4 \nn!  =   24 \n\n$ poetry run python greeter.py calculate_factorial  4 \nusage: greeter.py  [ -h ]   { factorial,goodbye,mientras,\u043f\u043e\u043a\u0430,hello }  ...\ngreeter.py: error: argument command: invalid choice:  'calculate_factorial'   ( choose from  'factorial' ,  'goodbye' ,  'mientras' ,  '\u043f\u043e\u043a\u0430' ,  'hello' )",
            "title": "Command Names"
        },
        {
            "location": "/tutorial/#ignore-methods",
            "text": "By default, Cliar converts all non-static and non-class methods of the  Cliar  subclass into CLI commands.  There are two ways to tell Cliar  not  to convert a method into a command: start its name with an underscore or use  ignore  decorator:  from   math   import   factorial ,   tau ,   pi  from   cliar   import   Cliar ,   set_help ,   set_metavars ,   set_arg_map ,   add_aliases ,   set_name ,   ignore  class   Greeter ( Cliar ): \n     '''Greeter app created with in Cliar.''' \n\n     def   _get_tau_value ( self ): \n         return   tau \n\n     @ignore \n     def   get_pi_value ( self ): \n         return   pi \n\n     def   constants ( self ): \n         print ( f '\u03c4 = {self._get_tau_value()}' ) \n         print ( f '\u03c0 = {self.get_pi_value()}' ) \n\n     ...   Only  constants  method will be exposed as a CLI command:  $ poetry run python greeter.py constants \u03c4   =   6 .283185307179586 \u03c0   =   3 .141592653589793\n\n$ poetry run python greeter.py get-pi-value\nusage: greeter.py  [ -h ]   { factorial,constants,goodbye,mientras,\u043f\u043e\u043a\u0430,hello }  ...\ngreeter.py: error: argument command: invalid choice:  'get-pi-value'   ( choose from  'factorial' ,  'constants' ,  'goodbye' ,  'mientras' ,  '\u043f\u043e\u043a\u0430' ,  'hello' )",
            "title": "Ignore Methods"
        },
        {
            "location": "/tutorial/#root-command",
            "text": "So far, we've defined args and flags only for commands, e.g.  hello  and  goodbye . But some flags are commonly defined for the entire script rather for a particular command, for example  --version . Also, sometimes you don't need commands at all: if there's only only action that your CLI does, defining a single command is redundant as the script name will suffice:  $ python say_hello.py            # We want this \n$ python say_hello.py say_hello  # rather than this.   In other words, we need a way to define a nameless command that runs when you run the script itself without any command.  Cliar lets you define such command by defining a special  _root  method:  class   Greeter ( Cliar ): \n     '''Greeter app created with in Cliar.''' \n\n     def   _root ( self ,   version = False ): \n         if   version : \n             print ( f 'Greeter 1.0.0.' ) \n         else : \n             print ( 'Welcome to Greeter!' ) \n     ...   If you run  greeter.py  with  --version  or  -v  flag, you'll see its version. If you call  greeter.py  without any flags or commands, you'll see a welcome message:  $ python greeter.py\nWelcome to Greeter!\n\n$ python greeter.py --version\nGreeter  1 .0.0.",
            "title": "Root Command"
        },
        {
            "location": "/changelog/",
            "text": "Changelog\n\u00b6\n\n\n1.2.2\n\u00b6\n\n\n\n\nMake \n_root\n not an abstract method.\n\n\n\n\n1.2.1\n\u00b6\n\n\n\n\nFix critical bug that disallowed string params.\n\n\n\n\n1.2.0\n\u00b6\n\n\n\n\nBoolean handler params are converted into \nstore_true\n arguments. Before that, params with default value of \nTrue\n were much confusingly converted into \nstore_false\n arguments.\n\n\nSupport \nList[int]\n and similar arg types. If the param type is a subclass of \ntyping.Iterable\n and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets.\n\n\nDo not print help whenever \n_root\n command is invoked.\n\n\nConvert the \ncliar\n module into a package.\n\n\nAdd tests.\n\n\nSwitch to Poetry.\n\n\n\n\n1.1.9\n\u00b6\n\n\n\n\nAdd the ability to set help messages for arguments.\n\n\nAdd the ability to set metavars for arguments.\n\n\n\n\n1.1.8\n\u00b6\n\n\n\n\n[Breaks backward compatibility]\n Base CLI class renamed from \nCLI\n to \nCliar\n.\n\n\nFixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.\n\n\n\n\n1.1.7\n\u00b6\n\n\n\n\nAdd the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.\n\n\n\n\n1.1.6\n\u00b6\n\n\n\n\nUnderscores in handler names are now replaced with dashes when the corresponding command name is generated.\n\n\n\n\n1.1.5\n\u00b6\n\n\n\n\nOptional arguments are now prepended with '--', not '-'.\n\n\nShort argument names are now generated from the long ones: \nname\n handler arg corresponds to \n-n\n and \n--name\n commandline args.\n\n\nPython 2 support dropped. Python 3.5+ required.\n\n\nCode refactored, type hints added.\n\n\n\n\n1.1.4\n\u00b6\n\n\n\n\nCode improvements for API documentation.\n\n\n\n\n1.1.3\n\u00b6\n\n\n\n\nCode cleanup.\n\n\n\n\n1.1.2\n\u00b6\n\n\n\n\nSetup: Python version check improved.\n\n\n\n\n1.1.1\n\u00b6\n\n\n\n\nPython 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed.\n\n\nIf only the _root handler is defined, the commands subparser is not added anymore.\n\n\nPackaging improved, the installation package now includes both Python 2 and 3 sources.\n\n\n\n\n1.1.0\n\u00b6\n\n\n\n\nCommand descriptions did not preserve line breaks from docstrings. Fixed.\n\n\n\n\n1.0.9\n\u00b6\n\n\n\n\nCommands now use the first docstring line as help and the whole docstring as description.\n\n\n\n\n1.0.8\n\u00b6\n\n\n\n\nDescription and help texts now preserve line breaks from docstrings.\n\n\n\n\n1.0.7\n\u00b6\n\n\n\n\nSupport of multiple values for a single arg added.\n\n\n\n\n1.0.6\n\u00b6\n\n\n\n\nCommand-line args are now parsed by explicitly calling the \n.parse()\n method.\n\n\n\n\n1.0.5\n\u00b6\n\n\n\n\nThe \nignore\n decorator added to exclude a method from being converted into a command.\n\n\n\n\n1.0.4\n\u00b6\n\n\n\n\nNested CLI methods would not override parent methods. Fixed.\n\n\n\n\n1.0.3\n\u00b6\n\n\n\n\nPython 2 support added.\n\n\n\n\n1.0.2\n\u00b6\n\n\n\n\nDocstring added to the add_aliases function.\n\n\nThe set_name function is now less hacky.\n\n\n\n\n1.0.1\n\u00b6\n\n\n\n\nAlias support added with the \"add_aliases\" decorator.\n\n\n\n\n1.0.0\n\u00b6\n\n\n\n\nFirst version. Changelog started.",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#changelog",
            "text": "",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#122",
            "text": "Make  _root  not an abstract method.",
            "title": "1.2.2"
        },
        {
            "location": "/changelog/#121",
            "text": "Fix critical bug that disallowed string params.",
            "title": "1.2.1"
        },
        {
            "location": "/changelog/#120",
            "text": "Boolean handler params are converted into  store_true  arguments. Before that, params with default value of  True  were much confusingly converted into  store_false  arguments.  Support  List[int]  and similar arg types. If the param type is a subclass of  typing.Iterable  and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets.  Do not print help whenever  _root  command is invoked.  Convert the  cliar  module into a package.  Add tests.  Switch to Poetry.",
            "title": "1.2.0"
        },
        {
            "location": "/changelog/#119",
            "text": "Add the ability to set help messages for arguments.  Add the ability to set metavars for arguments.",
            "title": "1.1.9"
        },
        {
            "location": "/changelog/#118",
            "text": "[Breaks backward compatibility]  Base CLI class renamed from  CLI  to  Cliar .  Fixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.",
            "title": "1.1.8"
        },
        {
            "location": "/changelog/#117",
            "text": "Add the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.",
            "title": "1.1.7"
        },
        {
            "location": "/changelog/#116",
            "text": "Underscores in handler names are now replaced with dashes when the corresponding command name is generated.",
            "title": "1.1.6"
        },
        {
            "location": "/changelog/#115",
            "text": "Optional arguments are now prepended with '--', not '-'.  Short argument names are now generated from the long ones:  name  handler arg corresponds to  -n  and  --name  commandline args.  Python 2 support dropped. Python 3.5+ required.  Code refactored, type hints added.",
            "title": "1.1.5"
        },
        {
            "location": "/changelog/#114",
            "text": "Code improvements for API documentation.",
            "title": "1.1.4"
        },
        {
            "location": "/changelog/#113",
            "text": "Code cleanup.",
            "title": "1.1.3"
        },
        {
            "location": "/changelog/#112",
            "text": "Setup: Python version check improved.",
            "title": "1.1.2"
        },
        {
            "location": "/changelog/#111",
            "text": "Python 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed.  If only the _root handler is defined, the commands subparser is not added anymore.  Packaging improved, the installation package now includes both Python 2 and 3 sources.",
            "title": "1.1.1"
        },
        {
            "location": "/changelog/#110",
            "text": "Command descriptions did not preserve line breaks from docstrings. Fixed.",
            "title": "1.1.0"
        },
        {
            "location": "/changelog/#109",
            "text": "Commands now use the first docstring line as help and the whole docstring as description.",
            "title": "1.0.9"
        },
        {
            "location": "/changelog/#108",
            "text": "Description and help texts now preserve line breaks from docstrings.",
            "title": "1.0.8"
        },
        {
            "location": "/changelog/#107",
            "text": "Support of multiple values for a single arg added.",
            "title": "1.0.7"
        },
        {
            "location": "/changelog/#106",
            "text": "Command-line args are now parsed by explicitly calling the  .parse()  method.",
            "title": "1.0.6"
        },
        {
            "location": "/changelog/#105",
            "text": "The  ignore  decorator added to exclude a method from being converted into a command.",
            "title": "1.0.5"
        },
        {
            "location": "/changelog/#104",
            "text": "Nested CLI methods would not override parent methods. Fixed.",
            "title": "1.0.4"
        },
        {
            "location": "/changelog/#103",
            "text": "Python 2 support added.",
            "title": "1.0.3"
        },
        {
            "location": "/changelog/#102",
            "text": "Docstring added to the add_aliases function.  The set_name function is now less hacky.",
            "title": "1.0.2"
        },
        {
            "location": "/changelog/#101",
            "text": "Alias support added with the \"add_aliases\" decorator.",
            "title": "1.0.1"
        },
        {
            "location": "/changelog/#100",
            "text": "First version. Changelog started.",
            "title": "1.0.0"
        }
    ]
}