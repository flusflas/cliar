{
    "docs": [
        {
            "location": "/",
            "text": "Cliar\n\u00b6\n\n\nCliar is yet another Python package to create commandline interfaces. It focuses on simplicity, extensibility, and testability:\n\n\n\n\nCreating a CLI is as simple as subclassing \ncliar.Cliar\n.\n\n\nExtending a CLI is as simple as extending a class via inheritance.\n\n\nTesting a CLI is as simple as unittesting a class methods.\n\n\n\n\nCliar's mission is to let the programmer focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in the programmer's way, so it provides the means to customize the generated CLI.\n\n\nInstallation\n\u00b6\n\n\npip install cliar\n\n\n\n\n\nCliar runs on Python 3.6+ on Windows, Linux, and Mac. There are no dependencies outside Python's standard library.\n\n\nBasic Usage\n\u00b6\n\n\nLet's create a commandline calculator that adds two real numbers with Cliar:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n\n\n\n\nclass\n \nCalculator\n(\nCliar\n):\n\n    \n'''Calculator app.'''\n\n\n    \ndef\n \nadd\n(\nself\n,\n \nx\n:\n \nfloat\n,\n \ny\n:\n \nfloat\n):\n\n        \n'''Add two real numbers.'''\n\n\n        \nprint\n(\nf\n'The sum of {x} and {y} is {x+y}.'\n)\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nCalculator\n()\n.\nparse\n()\n\n\n\n\n\n\nSave this code to \ncalc.py\n and run it with different inputs:\n\n\n\n\n\n\nValid input:\n\n\n$ python run calc.py add \n12\n \n34\n\nThe sum of \n12\n.0 and \n34\n.0 is \n46\n.0.\n\n\n\n\n\n\n\n\n\nInvalid input:\n\n\n$ python run calc.py foo bar\nusage: calc.py add \n[\n-h\n]\n x y\ncalc.py add: error: argument x: invalid float value: \n'foo'\n\n\n\n\n\n\n\n\n\n\nGet help:\n\n\n$ python run calc.py -h\nusage: calc.py \n[\n-h\n]\n \n{\nadd\n}\n ...\n\nCalculator app.\n\noptional arguments:\n-h, --help  show this \nhelp\n message and \nexit\n\n\ncommands:\n\n{\nadd\n}\n       Available commands:\n    add       Add two real numbers.\n\n\n\n\n\n\n\n\n\nGet help for a specific command:\n\n\n$ python calc.py add -h\nusage: calc.py add \n[\n-h\n]\n x y\n\nAdd two real numbers.\n\npositional arguments:\nx\ny\n\noptional arguments:\n-h, --help  show this \nhelp\n message and \nexit\n\n\n\n\n\n\n\n\n\n\nThere are a few things to note here:\n\n\n\n\n\n\nIt's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar.\n\n\n\n\n\n\nThe \nadd\n method is converted into \nadd\n command, and its positional params are converted into positional commandline args.\n\n\n\n\n\n\nWe don't convert \nx\n or \ny\n to \nfloat\n or handle any potential conversion errors in the \nadd\n body. Instead, we treat \nx\n and \ny\n as if they were already guaranteed to be floats. That's because Cliar does the validation and conversion for us, using the information from \nadd\n's type hints. Note how invalid input doesn't even reach your code.\n\n\n\n\n\n\nThe \n--help\n and \n-h\n flags are added automatically and the help messages are generated from the docstrings.\n\n\n\n\n\n\nBut wait! There's more!\n\u00b6\n\n\nCliar lets you customize your CLI in many ways! \nRead the tutorial\n to learn all Cliar's powers.\n\n\nHappy hacking!",
            "title": "Home"
        },
        {
            "location": "/#cliar",
            "text": "Cliar is yet another Python package to create commandline interfaces. It focuses on simplicity, extensibility, and testability:   Creating a CLI is as simple as subclassing  cliar.Cliar .  Extending a CLI is as simple as extending a class via inheritance.  Testing a CLI is as simple as unittesting a class methods.   Cliar's mission is to let the programmer focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in the programmer's way, so it provides the means to customize the generated CLI.",
            "title": "Cliar"
        },
        {
            "location": "/#installation",
            "text": "pip install cliar  Cliar runs on Python 3.6+ on Windows, Linux, and Mac. There are no dependencies outside Python's standard library.",
            "title": "Installation"
        },
        {
            "location": "/#basic-usage",
            "text": "Let's create a commandline calculator that adds two real numbers with Cliar:  from   cliar   import   Cliar  class   Calculator ( Cliar ): \n     '''Calculator app.''' \n\n     def   add ( self ,   x :   float ,   y :   float ): \n         '''Add two real numbers.''' \n\n         print ( f 'The sum of {x} and {y} is {x+y}.' )  if   __name__   ==   '__main__' : \n     Calculator () . parse ()   Save this code to  calc.py  and run it with different inputs:    Valid input:  $ python run calc.py add  12   34 \nThe sum of  12 .0 and  34 .0 is  46 .0.    Invalid input:  $ python run calc.py foo bar\nusage: calc.py add  [ -h ]  x y\ncalc.py add: error: argument x: invalid float value:  'foo'     Get help:  $ python run calc.py -h\nusage: calc.py  [ -h ]   { add }  ...\n\nCalculator app.\n\noptional arguments:\n-h, --help  show this  help  message and  exit \n\ncommands: { add }        Available commands:\n    add       Add two real numbers.    Get help for a specific command:  $ python calc.py add -h\nusage: calc.py add  [ -h ]  x y\n\nAdd two real numbers.\n\npositional arguments:\nx\ny\n\noptional arguments:\n-h, --help  show this  help  message and  exit     There are a few things to note here:    It's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar.    The  add  method is converted into  add  command, and its positional params are converted into positional commandline args.    We don't convert  x  or  y  to  float  or handle any potential conversion errors in the  add  body. Instead, we treat  x  and  y  as if they were already guaranteed to be floats. That's because Cliar does the validation and conversion for us, using the information from  add 's type hints. Note how invalid input doesn't even reach your code.    The  --help  and  -h  flags are added automatically and the help messages are generated from the docstrings.",
            "title": "Basic Usage"
        },
        {
            "location": "/#but-wait-theres-more",
            "text": "Cliar lets you customize your CLI in many ways!  Read the tutorial  to learn all Cliar's powers.  Happy hacking!",
            "title": "But wait! There's more!"
        },
        {
            "location": "/tutorial/",
            "text": "Tutorial\n\u00b6\n\n\nIn this tutorial, we'll extend the simple calculator app we created in \nBasic Usage\n with optional arguments, more commands, argument annotations. We'll also look at how Cliar lets you customize your CLI by simply decorating methods. Finally, we'll learn how to test CLIs written with Cliar.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#tutorial",
            "text": "In this tutorial, we'll extend the simple calculator app we created in  Basic Usage  with optional arguments, more commands, argument annotations. We'll also look at how Cliar lets you customize your CLI by simply decorating methods. Finally, we'll learn how to test CLIs written with Cliar.",
            "title": "Tutorial"
        },
        {
            "location": "/changelog/",
            "text": "Changelog\n\u00b6\n\n\n1.2.2\n\u00b6\n\n\n\n\nMake \n_root\n not an abstract method.\n\n\n\n\n1.2.1\n\u00b6\n\n\n\n\nFix critical bug that disallowed string params.\n\n\n\n\n1.2.0\n\u00b6\n\n\n\n\nBoolean handler params are converted into \nstore_true\n arguments. Before that, params with default value of \nTrue\n were much confusingly converted into \nstore_false\n arguments.\n\n\nSupport \nList[int]\n and similar arg types. If the param type is a subclass of \ntyping.Iterable\n and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets.\n\n\nDo not print help whenever \n_root\n command is invoked.\n\n\nConvert the \ncliar\n module into a package.\n\n\nAdd tests.\n\n\nSwitch to Poetry.\n\n\n\n\n1.1.9\n\u00b6\n\n\n\n\nAdd the ability to set help messages for arguments.\n\n\nAdd the ability to set metavars for arguments.\n\n\n\n\n1.1.8\n\u00b6\n\n\n\n\n[Breaks backward compatibility]\n Base CLI class renamed from \nCLI\n to \nCliar\n.\n\n\nFixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.\n\n\n\n\n1.1.7\n\u00b6\n\n\n\n\nAdd the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.\n\n\n\n\n1.1.6\n\u00b6\n\n\n\n\nUnderscores in handler names are now replaced with dashes when the corresponding command name is generated.\n\n\n\n\n1.1.5\n\u00b6\n\n\n\n\nOptional arguments are now prepended with '--', not '-'.\n\n\nShort argument names are now generated from the long ones: \nname\n handler arg corresponds to \n-n\n and \n--name\n commandline args.\n\n\nPython 2 support dropped. Python 3.5+ required.\n\n\nCode refactored, type hints added.\n\n\n\n\n1.1.4\n\u00b6\n\n\n\n\nCode improvements for API documentation.\n\n\n\n\n1.1.3\n\u00b6\n\n\n\n\nCode cleanup.\n\n\n\n\n1.1.2\n\u00b6\n\n\n\n\nSetup: Python version check improved.\n\n\n\n\n1.1.1\n\u00b6\n\n\n\n\nPython 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed.\n\n\nIf only the _root handler is defined, the commands subparser is not added anymore.\n\n\nPackaging improved, the installation package now includes both Python 2 and 3 sources.\n\n\n\n\n1.1.0\n\u00b6\n\n\n\n\nCommand descriptions did not preserve line breaks from docstrings. Fixed.\n\n\n\n\n1.0.9\n\u00b6\n\n\n\n\nCommands now use the first docstring line as help and the whole docstring as description.\n\n\n\n\n1.0.8\n\u00b6\n\n\n\n\nDescription and help texts now preserve line breaks from docstrings.\n\n\n\n\n1.0.7\n\u00b6\n\n\n\n\nSupport of multiple values for a single arg added.\n\n\n\n\n1.0.6\n\u00b6\n\n\n\n\nCommand-line args are now parsed by explicitly calling the \n.parse()\n method.\n\n\n\n\n1.0.5\n\u00b6\n\n\n\n\nThe \nignore\n decorator added to exclude a method from being converted into a command.\n\n\n\n\n1.0.4\n\u00b6\n\n\n\n\nNested CLI methods would not override parent methods. Fixed.\n\n\n\n\n1.0.3\n\u00b6\n\n\n\n\nPython 2 support added.\n\n\n\n\n1.0.2\n\u00b6\n\n\n\n\nDocstring added to the add_aliases function.\n\n\nThe set_name function is now less hacky.\n\n\n\n\n1.0.1\n\u00b6\n\n\n\n\nAlias support added with the \"add_aliases\" decorator.\n\n\n\n\n1.0.0\n\u00b6\n\n\n\n\nFirst version. Changelog started.",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#changelog",
            "text": "",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#122",
            "text": "Make  _root  not an abstract method.",
            "title": "1.2.2"
        },
        {
            "location": "/changelog/#121",
            "text": "Fix critical bug that disallowed string params.",
            "title": "1.2.1"
        },
        {
            "location": "/changelog/#120",
            "text": "Boolean handler params are converted into  store_true  arguments. Before that, params with default value of  True  were much confusingly converted into  store_false  arguments.  Support  List[int]  and similar arg types. If the param type is a subclass of  typing.Iterable  and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets.  Do not print help whenever  _root  command is invoked.  Convert the  cliar  module into a package.  Add tests.  Switch to Poetry.",
            "title": "1.2.0"
        },
        {
            "location": "/changelog/#119",
            "text": "Add the ability to set help messages for arguments.  Add the ability to set metavars for arguments.",
            "title": "1.1.9"
        },
        {
            "location": "/changelog/#118",
            "text": "[Breaks backward compatibility]  Base CLI class renamed from  CLI  to  Cliar .  Fixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.",
            "title": "1.1.8"
        },
        {
            "location": "/changelog/#117",
            "text": "Add the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.",
            "title": "1.1.7"
        },
        {
            "location": "/changelog/#116",
            "text": "Underscores in handler names are now replaced with dashes when the corresponding command name is generated.",
            "title": "1.1.6"
        },
        {
            "location": "/changelog/#115",
            "text": "Optional arguments are now prepended with '--', not '-'.  Short argument names are now generated from the long ones:  name  handler arg corresponds to  -n  and  --name  commandline args.  Python 2 support dropped. Python 3.5+ required.  Code refactored, type hints added.",
            "title": "1.1.5"
        },
        {
            "location": "/changelog/#114",
            "text": "Code improvements for API documentation.",
            "title": "1.1.4"
        },
        {
            "location": "/changelog/#113",
            "text": "Code cleanup.",
            "title": "1.1.3"
        },
        {
            "location": "/changelog/#112",
            "text": "Setup: Python version check improved.",
            "title": "1.1.2"
        },
        {
            "location": "/changelog/#111",
            "text": "Python 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed.  If only the _root handler is defined, the commands subparser is not added anymore.  Packaging improved, the installation package now includes both Python 2 and 3 sources.",
            "title": "1.1.1"
        },
        {
            "location": "/changelog/#110",
            "text": "Command descriptions did not preserve line breaks from docstrings. Fixed.",
            "title": "1.1.0"
        },
        {
            "location": "/changelog/#109",
            "text": "Commands now use the first docstring line as help and the whole docstring as description.",
            "title": "1.0.9"
        },
        {
            "location": "/changelog/#108",
            "text": "Description and help texts now preserve line breaks from docstrings.",
            "title": "1.0.8"
        },
        {
            "location": "/changelog/#107",
            "text": "Support of multiple values for a single arg added.",
            "title": "1.0.7"
        },
        {
            "location": "/changelog/#106",
            "text": "Command-line args are now parsed by explicitly calling the  .parse()  method.",
            "title": "1.0.6"
        },
        {
            "location": "/changelog/#105",
            "text": "The  ignore  decorator added to exclude a method from being converted into a command.",
            "title": "1.0.5"
        },
        {
            "location": "/changelog/#104",
            "text": "Nested CLI methods would not override parent methods. Fixed.",
            "title": "1.0.4"
        },
        {
            "location": "/changelog/#103",
            "text": "Python 2 support added.",
            "title": "1.0.3"
        },
        {
            "location": "/changelog/#102",
            "text": "Docstring added to the add_aliases function.  The set_name function is now less hacky.",
            "title": "1.0.2"
        },
        {
            "location": "/changelog/#101",
            "text": "Alias support added with the \"add_aliases\" decorator.",
            "title": "1.0.1"
        },
        {
            "location": "/changelog/#100",
            "text": "First version. Changelog started.",
            "title": "1.0.0"
        }
    ]
}