{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cliar \u00b6 Cliar is a Python package to help you create commandline interfaces. It focuses on simplicity and extensibility: Creating a CLI is as simple as subclassing from cliar.Cliar . Extending a CLI is as simple as subclassing from a cliar.Cliar subclass. Cliar's mission is to let you focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in your way, so it provides the means to customize the generated CLI. Installation \u00b6 $ pip install cliar Cliar requires Python 3.6+ and is tested on Windows, Linux, and macOS. There are no dependencies outside Python's standard library. Basic Usage \u00b6 Let's create a commandline calculator that adds two floats: from cliar import Cliar class Calculator ( Cliar ): '''Calculator app.''' def add ( self , x : float , y : float ): '''Add two numbers.''' print ( f 'The sum of {x} and {y} is {x+y}.' ) if __name__ == '__main__' : Calculator () . parse () Save this code to calc.py and run it. Try different inputs: Valid input: $ python calc.py add 12 34 The sum of 12 .0 and 34 .0 is 46 .0. Invalid input: $ python calc.py add foo bar usage: calc.py add [ -h ] x y calc.py add: error: argument x: invalid float value: 'foo' Help: $ python calc . py - h usage : calc . py [ - h ] { add } ... Calculator app . optional arguments : - h , -- help show this help message and exit commands : { add } Available commands : add Add two numbers . Help for add command: $ python calc . py add - h usage : calc . py add [ - h ] x y Add two numbers . positional arguments : x y optional arguments : - h , -- help show this help message and exit A few thing to note: It's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar. add method is converted to add command, its positional params are converted to positional commandline args. There is no explicit conversion to float for x or y or error handling in the add method body. Instead, x and y are just treated as floats. Cliar converts the types using add 's type hints. Invalid input doesn't even reach your code. The --help and -h flags are added automatically and the help messages are generated from the docstrings. Read Next \u00b6 Tutorial \u2192 Cliar vs. Click vs. docopt \u2192","title":"Home"},{"location":"#cliar","text":"Cliar is a Python package to help you create commandline interfaces. It focuses on simplicity and extensibility: Creating a CLI is as simple as subclassing from cliar.Cliar . Extending a CLI is as simple as subclassing from a cliar.Cliar subclass. Cliar's mission is to let you focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in your way, so it provides the means to customize the generated CLI.","title":"Cliar"},{"location":"#installation","text":"$ pip install cliar Cliar requires Python 3.6+ and is tested on Windows, Linux, and macOS. There are no dependencies outside Python's standard library.","title":"Installation"},{"location":"#basic-usage","text":"Let's create a commandline calculator that adds two floats: from cliar import Cliar class Calculator ( Cliar ): '''Calculator app.''' def add ( self , x : float , y : float ): '''Add two numbers.''' print ( f 'The sum of {x} and {y} is {x+y}.' ) if __name__ == '__main__' : Calculator () . parse () Save this code to calc.py and run it. Try different inputs: Valid input: $ python calc.py add 12 34 The sum of 12 .0 and 34 .0 is 46 .0. Invalid input: $ python calc.py add foo bar usage: calc.py add [ -h ] x y calc.py add: error: argument x: invalid float value: 'foo' Help: $ python calc . py - h usage : calc . py [ - h ] { add } ... Calculator app . optional arguments : - h , -- help show this help message and exit commands : { add } Available commands : add Add two numbers . Help for add command: $ python calc . py add - h usage : calc . py add [ - h ] x y Add two numbers . positional arguments : x y optional arguments : - h , -- help show this help message and exit A few thing to note: It's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar. add method is converted to add command, its positional params are converted to positional commandline args. There is no explicit conversion to float for x or y or error handling in the add method body. Instead, x and y are just treated as floats. Cliar converts the types using add 's type hints. Invalid input doesn't even reach your code. The --help and -h flags are added automatically and the help messages are generated from the docstrings.","title":"Basic Usage"},{"location":"#read-next","text":"Tutorial \u2192 Cliar vs. Click vs. docopt \u2192","title":"Read Next"},{"location":"changelog/","text":"Changelog \u00b6 1.3.0 \u00b6 Add support for nested commands. Read more . Fix incorrect mapping from handler params to optional CLI args. 1.2.5 \u00b6 Prepare for postponed annotation evaluation, which will be the default in Python 4.0 (see #2). 1.2.4 \u00b6 Add show_defaults param to set_help util. Read more . 1.2.3 \u00b6 Fix Python 3.7 incompatibility. Add set_sharg_map to override or disable short arg names. 1.2.2 \u00b6 Make _root not an abstract method. 1.2.1 \u00b6 Fix critical bug that disallowed string params. 1.2.0 \u00b6 Boolean handler params are converted into store_true arguments. Before that, params with default value of True were much confusingly converted into store_false arguments. Support List[int] and similar arg types. If the param type is a subclass of typing.Iterable and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets. Do not print help whenever _root command is invoked. Convert the cliar module into a package. Add tests. Switch to Poetry. 1.1.9 \u00b6 Add the ability to set help messages for arguments. Add the ability to set metavars for arguments. 1.1.8 \u00b6 [Breaks backward compatibility] Base CLI class renamed from CLI to Cliar . Fixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores. 1.1.7 \u00b6 Add the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes. 1.1.6 \u00b6 Underscores in handler names are now replaced with dashes when the corresponding command name is generated. 1.1.5 \u00b6 Optional arguments are now prepended with '--', not '-'. Short argument names are now generated from the long ones: name handler arg corresponds to -n and --name commandline args. Python 2 support dropped. Python 3.5+ required. Code refactored, type hints added. 1.1.4 \u00b6 Code improvements for API documentation. 1.1.3 \u00b6 Code cleanup. 1.1.2 \u00b6 Setup: Python version check improved. 1.1.1 \u00b6 Python 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed. If only the _root handler is defined, the commands subparser is not added anymore. Packaging improved, the installation package now includes both Python 2 and 3 sources. 1.1.0 \u00b6 Command descriptions did not preserve line breaks from docstrings. Fixed. 1.0.9 \u00b6 Commands now use the first docstring line as help and the whole docstring as description. 1.0.8 \u00b6 Description and help texts now preserve line breaks from docstrings. 1.0.7 \u00b6 Support of multiple values for a single arg added. 1.0.6 \u00b6 Command-line args are now parsed by explicitly calling the .parse() method. 1.0.5 \u00b6 The ignore decorator added to exclude a method from being converted into a command. 1.0.4 \u00b6 Nested CLI methods would not override parent methods. Fixed. 1.0.3 \u00b6 Python 2 support added. 1.0.2 \u00b6 Docstring added to the add_aliases function. The set_name function is now less hacky. 1.0.1 \u00b6 Alias support added with the \"add_aliases\" decorator. 1.0.0 \u00b6 First version. Changelog started.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#130","text":"Add support for nested commands. Read more . Fix incorrect mapping from handler params to optional CLI args.","title":"1.3.0"},{"location":"changelog/#125","text":"Prepare for postponed annotation evaluation, which will be the default in Python 4.0 (see #2).","title":"1.2.5"},{"location":"changelog/#124","text":"Add show_defaults param to set_help util. Read more .","title":"1.2.4"},{"location":"changelog/#123","text":"Fix Python 3.7 incompatibility. Add set_sharg_map to override or disable short arg names.","title":"1.2.3"},{"location":"changelog/#122","text":"Make _root not an abstract method.","title":"1.2.2"},{"location":"changelog/#121","text":"Fix critical bug that disallowed string params.","title":"1.2.1"},{"location":"changelog/#120","text":"Boolean handler params are converted into store_true arguments. Before that, params with default value of True were much confusingly converted into store_false arguments. Support List[int] and similar arg types. If the param type is a subclass of typing.Iterable and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets. Do not print help whenever _root command is invoked. Convert the cliar module into a package. Add tests. Switch to Poetry.","title":"1.2.0"},{"location":"changelog/#119","text":"Add the ability to set help messages for arguments. Add the ability to set metavars for arguments.","title":"1.1.9"},{"location":"changelog/#118","text":"[Breaks backward compatibility] Base CLI class renamed from CLI to Cliar . Fixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.","title":"1.1.8"},{"location":"changelog/#117","text":"Add the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.","title":"1.1.7"},{"location":"changelog/#116","text":"Underscores in handler names are now replaced with dashes when the corresponding command name is generated.","title":"1.1.6"},{"location":"changelog/#115","text":"Optional arguments are now prepended with '--', not '-'. Short argument names are now generated from the long ones: name handler arg corresponds to -n and --name commandline args. Python 2 support dropped. Python 3.5+ required. Code refactored, type hints added.","title":"1.1.5"},{"location":"changelog/#114","text":"Code improvements for API documentation.","title":"1.1.4"},{"location":"changelog/#113","text":"Code cleanup.","title":"1.1.3"},{"location":"changelog/#112","text":"Setup: Python version check improved.","title":"1.1.2"},{"location":"changelog/#111","text":"Python 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed. If only the _root handler is defined, the commands subparser is not added anymore. Packaging improved, the installation package now includes both Python 2 and 3 sources.","title":"1.1.1"},{"location":"changelog/#110","text":"Command descriptions did not preserve line breaks from docstrings. Fixed.","title":"1.1.0"},{"location":"changelog/#109","text":"Commands now use the first docstring line as help and the whole docstring as description.","title":"1.0.9"},{"location":"changelog/#108","text":"Description and help texts now preserve line breaks from docstrings.","title":"1.0.8"},{"location":"changelog/#107","text":"Support of multiple values for a single arg added.","title":"1.0.7"},{"location":"changelog/#106","text":"Command-line args are now parsed by explicitly calling the .parse() method.","title":"1.0.6"},{"location":"changelog/#105","text":"The ignore decorator added to exclude a method from being converted into a command.","title":"1.0.5"},{"location":"changelog/#104","text":"Nested CLI methods would not override parent methods. Fixed.","title":"1.0.4"},{"location":"changelog/#103","text":"Python 2 support added.","title":"1.0.3"},{"location":"changelog/#102","text":"Docstring added to the add_aliases function. The set_name function is now less hacky.","title":"1.0.2"},{"location":"changelog/#101","text":"Alias support added with the \"add_aliases\" decorator.","title":"1.0.1"},{"location":"changelog/#100","text":"First version. Changelog started.","title":"1.0.0"},{"location":"comparison/","text":"Cliar vs. Click vs. docopt \u00b6 It may seem strange to develop yet another Python package for CLI creation when we already have great tools like Click and docopt. Why not use one of those? It turns out there's at least one area where Click and docopt just won't do\u2014 modular CLI . Below, I'll try to explain what I mean by modular CLIs and why they are important. A will also cover other things that make Cliar special. Name Modular CLIs DSL-free Magic-free Type casting Pun in name Cliar \u2714 \u2714 \u2714 \u2714 \u2714 Click \u274c \u2714 \u274c \u2714 \u2714 docopt \u274c \u274c \u2714 \u274c \u274c Note Of course, any tool lets you do anything. Below, when I say \"feature X is not supported by tool Y,\" I mean that the effort needed to implement X with Y is subjectively too high. I'm basing my conclusions on the solutions provided by the official documentations of the tools being compared. Feel free to disagree. Modular CLIs \u00b6 Imagine you're developing a CLI-based audio player. You want it to have a ton of features but you don't want to develop them all on your own. The core version will only play a given file, but the rest of the functionality will be implemented with extensions. You want the usage of the player to be something like this: $ player play file.mp3 # Core functionality $ pip install player.ext.seek # Install extension $ player seek \"1:23\" # Extension-provided functionality This approach has several benefits: the user will be able to install only the parts they need you will be able to delegate responsibility to the community new commands are added via a unified API, which is the same for core and third-party developers So, your job is provide a way for third parties to add commands to the basic CLI and override existing commands. With docopt this is almost impossible since CLIs are declared in plaintext using a DSL: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt if __name__ == '__main__' : arguments = docopt ( __doc__ ) Adding a new command means adding a line into a spec before it gets parsed, so the on;y way an extension can add a new command to the base CLI is by inserting lines into the base CLI spec. This is inconvenient if you're adding one command, but it's a nightmare if you're creating an API for adding unlimited commands: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt from player.ext.seek import insert_seek_command # \"insert_seek_command\" function inserts \"player seek <pos>\" # after \"player play\". You can already feel how quickly it gets old. if __name__ == '__main__' : extended_doc = insert_seek_command ( __doc__ ) arguments = docopt ( extended_doc ) With Click , you can reuse commands from one CLI in another one: # In file a: cli = click . Group () @cli.command () def cmd_a (): print ( \"You called cmd_a\" ) # In file b: from a import cli @cli.command () def cmd_b (): print ( \"You called cmd_b\" ) Thanks to /u/Brian for the code sample . However, you can't reuse commands from multiple third-party modules in one CLI, which is what we want. That's because command reuse relations are defined with decorators, and you can't decorate an imported function. In other words, you can create a new player that implements seek and borrows play from player , but you can't add seek into player . With Cliar , extending an existing CLI is trivial. Since in Cliar a CLI is a regular Python class, extending it means extending the class the most natural way\u2014with inheritance. Just subclass your CLI from as many Cliar ancestors as you need: from cliar import Cliar # Basic CLI: class BasicCLI ( CLiar ): def play ( self , path ): ... # Seek extension: class SeekCLI ( Cliar ): def seek ( self , position ): ... # Complete CLI: class CLI ( BasicCLI , SeekCLI , * MoreExtensions ): '''The complete CLI that borrows from the basic CLI and extensionss. Notice that the class body is empty: the logic is already implemented by the parents. ''' pass Cliar relies on Python's standard mechanisms and doesn't reinvent the wheel when it comes to adding new features to objects. Python supports both single and multiple inheritance, so CLI extension goes both ways: you can create a completely new interface that borrows from an existing one or build an interface from extensions. DSL-Free \u00b6 I believe DSLs should be avoided whenever pure Python is enough. A DSL requires time to learn, and the knowledge you gain is virtually useless anywhere outside the scope of the DSL, which is by definition the app it's used in. Note This thought along with other great ones has been beautifully explained by Robert E Brewer in The Zen in Cherrypy . In Docopt , you describe your CLI using a DSL. Then, you ask docopt to parse the commandline string and pass the extracted values to the business logic. The interface is completely separated from the business logic. It may seem a good idea until you actually start using docopt. What happens is you end up duplicating argument definitions all the time: '''Player. Usage: player play <file> player seek <position> player (-h | --help) Options: -h --help Show this screen. ''' # one time from docopt import docopt def play ( file ): # two times ... def seek ( position ): ... if __name__ == '__main__' : arguments = docopt ( __doc__ ) if arguments . get ( 'play' ): # three times play ( arguments [ '<file>' ]) elif arguments . get ( 'seek' ): seek ( arguments [ '<position>' ]) ... # ...and it goes on and on and on. Even in this toy example you can see how much redundant code this pattern spawns. Click and Cliar are DSL-free. Whereas docopt is \"spec first,\" Click and Cliar are \"code first\": they generate the usage text from the code, not the other way around. Magic-Free \u00b6 Magic is atypical behavior driven by a hidden mechanism. It may give a short \"wow\" effect, but the price to pay is that your code becomes harder to debug and harder to follow. Writing idiomatic Python generally means avoiding magic. It's easy to see if a tool is \"magical\": if after you remove it from the code it breaks, the tool was magical. Docopt , for example, is magic-free. If you remove the __doc__ parsing part, the remaining code is still 100% valid Python. Removing docopt does not break you program, it just removes the commandline parsing functionality: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' # from docopt import docopt if __name__ == '__main__' : # arguments = docopt(__doc__) pass Click , on the other hand, is full of magic. Let's examine the hello world example from the Click documentation : import click @click.command () @click.option ( '--count' , default = 1 , help = 'Number of greetings.' ) @click.option ( '--name' , prompt = 'Your name' , help = 'The person to greet.' ) def hello ( count , name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" for x in range ( count ): click . echo ( 'Hello %s !' % name ) if __name__ == '__main__' : hello () Note that hello function accepts two positional arguments, count and name , but we call it without any arguments. That's because the params are added by the decorators based on the arguments of the decorator generators ( --count and --name ). This is broken code only forced to work by the magic of Click's decorators. Also, Click forces you to use its own echo function instead of the good old print. I'm sure this is justified but it still is confusing. Cliar is magic-free. The class you describe your CLI with is a regular Python class. If you remove Cliar from its parents, the class will remain functional. It will continue to contain all the business logic, only without the CLI: # from cliar import Cliar # class Player(Cliar): class Player ( object ): def play ( self , file ): print ( f 'Playing {file}' ) Cliar's decorators like set_name or add_aliases can also be safely remove without breaking any code. Type Casting \u00b6 In commandline, any argument or flag value is a string. Converting strings to numbers and other types manually within business logic is tedious, requires dancing with exception handling, and, most importantly, has nothing to do with the business logic itself: it's a necessity induced by the fact the shell works only with strings and Python works with all sorts of types rather than a valuable data processing within business logic. Docopt doesn't attempt to cast types. It just parses a string into smaller ones in a nicely structured way, leaving all the necessary processing to the programmer. args = docopt ( __doc__ ) if args [ 'play' ]: file = Path ( args [ '<file>' ]) Click lets you define an argument and option type in the decorator constructor: @click.argument ( 'num' , type = int ) If the type is not set, Click tries to infer it from the default value. It that's not set as well, string is assumed. Cliar lets you define argument and option type with type hints. The logic is similar to Click's: if the type hint is given, use it, if not, infer the type from the default value, otherwise assume string: def play ( file : Path , num = 1 )","title":"Cliar vs. Click vs. docopt"},{"location":"comparison/#cliar-vs-click-vs-docopt","text":"It may seem strange to develop yet another Python package for CLI creation when we already have great tools like Click and docopt. Why not use one of those? It turns out there's at least one area where Click and docopt just won't do\u2014 modular CLI . Below, I'll try to explain what I mean by modular CLIs and why they are important. A will also cover other things that make Cliar special. Name Modular CLIs DSL-free Magic-free Type casting Pun in name Cliar \u2714 \u2714 \u2714 \u2714 \u2714 Click \u274c \u2714 \u274c \u2714 \u2714 docopt \u274c \u274c \u2714 \u274c \u274c Note Of course, any tool lets you do anything. Below, when I say \"feature X is not supported by tool Y,\" I mean that the effort needed to implement X with Y is subjectively too high. I'm basing my conclusions on the solutions provided by the official documentations of the tools being compared. Feel free to disagree.","title":"Cliar vs. Click vs. docopt"},{"location":"comparison/#modular-clis","text":"Imagine you're developing a CLI-based audio player. You want it to have a ton of features but you don't want to develop them all on your own. The core version will only play a given file, but the rest of the functionality will be implemented with extensions. You want the usage of the player to be something like this: $ player play file.mp3 # Core functionality $ pip install player.ext.seek # Install extension $ player seek \"1:23\" # Extension-provided functionality This approach has several benefits: the user will be able to install only the parts they need you will be able to delegate responsibility to the community new commands are added via a unified API, which is the same for core and third-party developers So, your job is provide a way for third parties to add commands to the basic CLI and override existing commands. With docopt this is almost impossible since CLIs are declared in plaintext using a DSL: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt if __name__ == '__main__' : arguments = docopt ( __doc__ ) Adding a new command means adding a line into a spec before it gets parsed, so the on;y way an extension can add a new command to the base CLI is by inserting lines into the base CLI spec. This is inconvenient if you're adding one command, but it's a nightmare if you're creating an API for adding unlimited commands: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt from player.ext.seek import insert_seek_command # \"insert_seek_command\" function inserts \"player seek <pos>\" # after \"player play\". You can already feel how quickly it gets old. if __name__ == '__main__' : extended_doc = insert_seek_command ( __doc__ ) arguments = docopt ( extended_doc ) With Click , you can reuse commands from one CLI in another one: # In file a: cli = click . Group () @cli.command () def cmd_a (): print ( \"You called cmd_a\" ) # In file b: from a import cli @cli.command () def cmd_b (): print ( \"You called cmd_b\" ) Thanks to /u/Brian for the code sample . However, you can't reuse commands from multiple third-party modules in one CLI, which is what we want. That's because command reuse relations are defined with decorators, and you can't decorate an imported function. In other words, you can create a new player that implements seek and borrows play from player , but you can't add seek into player . With Cliar , extending an existing CLI is trivial. Since in Cliar a CLI is a regular Python class, extending it means extending the class the most natural way\u2014with inheritance. Just subclass your CLI from as many Cliar ancestors as you need: from cliar import Cliar # Basic CLI: class BasicCLI ( CLiar ): def play ( self , path ): ... # Seek extension: class SeekCLI ( Cliar ): def seek ( self , position ): ... # Complete CLI: class CLI ( BasicCLI , SeekCLI , * MoreExtensions ): '''The complete CLI that borrows from the basic CLI and extensionss. Notice that the class body is empty: the logic is already implemented by the parents. ''' pass Cliar relies on Python's standard mechanisms and doesn't reinvent the wheel when it comes to adding new features to objects. Python supports both single and multiple inheritance, so CLI extension goes both ways: you can create a completely new interface that borrows from an existing one or build an interface from extensions.","title":"Modular CLIs"},{"location":"comparison/#dsl-free","text":"I believe DSLs should be avoided whenever pure Python is enough. A DSL requires time to learn, and the knowledge you gain is virtually useless anywhere outside the scope of the DSL, which is by definition the app it's used in. Note This thought along with other great ones has been beautifully explained by Robert E Brewer in The Zen in Cherrypy . In Docopt , you describe your CLI using a DSL. Then, you ask docopt to parse the commandline string and pass the extracted values to the business logic. The interface is completely separated from the business logic. It may seem a good idea until you actually start using docopt. What happens is you end up duplicating argument definitions all the time: '''Player. Usage: player play <file> player seek <position> player (-h | --help) Options: -h --help Show this screen. ''' # one time from docopt import docopt def play ( file ): # two times ... def seek ( position ): ... if __name__ == '__main__' : arguments = docopt ( __doc__ ) if arguments . get ( 'play' ): # three times play ( arguments [ '<file>' ]) elif arguments . get ( 'seek' ): seek ( arguments [ '<position>' ]) ... # ...and it goes on and on and on. Even in this toy example you can see how much redundant code this pattern spawns. Click and Cliar are DSL-free. Whereas docopt is \"spec first,\" Click and Cliar are \"code first\": they generate the usage text from the code, not the other way around.","title":"DSL-Free"},{"location":"comparison/#magic-free","text":"Magic is atypical behavior driven by a hidden mechanism. It may give a short \"wow\" effect, but the price to pay is that your code becomes harder to debug and harder to follow. Writing idiomatic Python generally means avoiding magic. It's easy to see if a tool is \"magical\": if after you remove it from the code it breaks, the tool was magical. Docopt , for example, is magic-free. If you remove the __doc__ parsing part, the remaining code is still 100% valid Python. Removing docopt does not break you program, it just removes the commandline parsing functionality: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' # from docopt import docopt if __name__ == '__main__' : # arguments = docopt(__doc__) pass Click , on the other hand, is full of magic. Let's examine the hello world example from the Click documentation : import click @click.command () @click.option ( '--count' , default = 1 , help = 'Number of greetings.' ) @click.option ( '--name' , prompt = 'Your name' , help = 'The person to greet.' ) def hello ( count , name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" for x in range ( count ): click . echo ( 'Hello %s !' % name ) if __name__ == '__main__' : hello () Note that hello function accepts two positional arguments, count and name , but we call it without any arguments. That's because the params are added by the decorators based on the arguments of the decorator generators ( --count and --name ). This is broken code only forced to work by the magic of Click's decorators. Also, Click forces you to use its own echo function instead of the good old print. I'm sure this is justified but it still is confusing. Cliar is magic-free. The class you describe your CLI with is a regular Python class. If you remove Cliar from its parents, the class will remain functional. It will continue to contain all the business logic, only without the CLI: # from cliar import Cliar # class Player(Cliar): class Player ( object ): def play ( self , file ): print ( f 'Playing {file}' ) Cliar's decorators like set_name or add_aliases can also be safely remove without breaking any code.","title":"Magic-Free"},{"location":"comparison/#type-casting","text":"In commandline, any argument or flag value is a string. Converting strings to numbers and other types manually within business logic is tedious, requires dancing with exception handling, and, most importantly, has nothing to do with the business logic itself: it's a necessity induced by the fact the shell works only with strings and Python works with all sorts of types rather than a valuable data processing within business logic. Docopt doesn't attempt to cast types. It just parses a string into smaller ones in a nicely structured way, leaving all the necessary processing to the programmer. args = docopt ( __doc__ ) if args [ 'play' ]: file = Path ( args [ '<file>' ]) Click lets you define an argument and option type in the decorator constructor: @click.argument ( 'num' , type = int ) If the type is not set, Click tries to infer it from the default value. It that's not set as well, string is assumed. Cliar lets you define argument and option type with type hints. The logic is similar to Click's: if the type hint is given, use it, if not, infer the type from the default value, otherwise assume string: def play ( file : Path , num = 1 )","title":"Type Casting"},{"location":"tutorial/","text":"Tutorial \u00b6 Download the complete sample app: greeter.py Hello World \u00b6 In Cliar, commandline interfaces are represented by Python classes subclassed from Cliar . Cliar turns the class methods into commands and their params into args. Let's create a simple CLI that says \"Hello World!\" when you call hello command: from cliar import Cliar class Greeter ( Cliar ): # Define a regular Python class def hello ( self ): # and a regular method, print ( 'Hello World!' ) # which implements the business logic. if __name__ == '__main__' : Greeter () . parse () # Instantiate the class and run `parse` method. Save this code into greeter.py and run it with Python: $ python greeter.py hello Hello World! And here it is: your first CLI created with Cliar! That was easy, wasn't it? Optional Flags \u00b6 Let's enhance hello method to shout the greeting loud if --shout flag is passed: def hello ( self , shout = False ): greeting = 'Hello World!' if shout : print ( greeting . upper ()) else : print ( greeting ) Try running greeter.py with and without the newly defined flag: $ python greeter.py hello --shout HELLO WORLD! $ python greeter.py hello -s # Short version works, too! HELLO WORLD! $ python greeter.py hello Hello World! Cliar did a few things for us here: shout is an optional param, so it was converted into an optional flag since shout default value is False , Cliar inferred its type as bool , so we can use it as such inside hello body not only was --shout flag generated from the eponymous shout param, but a short version -s was also generated Positional Arguments \u00b6 Ok, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to hello : def hello ( self , name , shout = False ): greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) Try it: $ python greeter.py hello John Hello John! $ python greeter.py hello John --shout HELLO JOHN! $ python greeter.py hello -s John HELLO JOHN! $ python greeter.py hello usage: greeter.py hello [ -h ] [ -s ] name greeter.py hello: error: the following arguments are required: name Help Messages \u00b6 If you run greeter.py with --help or -h flag, you'll see the help message generated by Cliar: $ python greeter.py --help usage: greeter.py [ -h ] { hello } ... optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello $ python greeter.py hello --help usage: greeter.py hello [ -h ] [ -s ] name positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout Although it does show some useful information, it's still quite poor: there's no app or command description or information about --shout or name arguments. First, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those: class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) Try calling the help messages now: $ python greeter.py -h usage: greeter.py [ -h ] { hello } ... Greeter app created with in Cliar. optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello Say hello to { name } . $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout That's much better! Now, let's add descriptions for --shout and name arguments. Hint self._parser is an ArgumentParser instance, so you can use all its methods and attributes, like print_help or usage . Argument Descriptions \u00b6 To add description for arguments, use set_help decorator: from cliar import Cliar , set_help ... @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) The decorator takes a mapping from param names to help messages. Call the help message for hello command: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting To show default values for optional params, add show_defaults = True to set_help : ... @set_help ( { 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }, show_defaults = True ) def hello ( self , name , shout = False ): ... Call help again to see the default value: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting ( default: False ) Metavars \u00b6 Metavar is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for name param the metavar is called name : $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting Let's change it to NAME , just so it's more visible in the line. To do that, use set_metavars decorator: from cliar import Cliar , set_help , set_metavars ... @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) The decorator takes a mapping from param names to metavars. Call the help message for hello : usage: greeter.py hello [ -h ] [ -s ] NAME Say hello. positional arguments: NAME The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting Type Casting \u00b6 Cliar can cast the types of args on the fly. To enable type casting, add a type hint to the param or set a default value for it. To showcase this feature, let's add a flag -n that will tell how many times we want the greeting to appear on the screen: @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' for _ in range ( n ): # Cliar guarantees `n` is an integer if shout : print ( greeting . upper ()) else : print ( greeting ) Note that inside hello code, we never convert n to integer or wrap anything in try blocks. Cliar cares about all that, allowing the programmer to focus on the business logic. Let's call hello with the new flag: $ python greeter.py hello John -n 2 Hello John! Hello John! Let's see what happens if we pass a non-integer value to -n : $ python greeter.py hello John -n foo usage: greeter.py hello [ -h ] [ -n N ] [ -s ] NAME greeter.py hello: error: argument -n/--n: invalid int value: 'foo' Because the passed value is invalid, Cliar stopped the execution before it even reached hello . This behavior guarantees that your code is always executed with valid input. Hint You can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using open as the param type: def read_from_file ( input_file : open ): lines = input_file . readlines () If you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed. Note If no type is set for a param, str is implied by default. So, name: str is the same as just name . Argument Names \u00b6 By default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name: name is turned into --name , and upper_limit into --upper-limit ; the first letter is used as a short option: -n for --name , -u for --upper-limit . In the previous example, -n is a rather poor name for a flag. Something more descriptive, like --repeat would be better. Cliar lets you set the names of the args without changing the handler code at all. Just use set_arg_map decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' for _ in range ( n ): if shout : print ( greeting . upper ()) else : print ( greeting ) Now you can use --repeat or -r instead of -n : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -r 2 Hello John! Hello John! Hint This decorator lets you use Python's reserved words as arg names: --for , --with , etc. You can also override argument short names specifically. This is useful when you have several arguments that start with the same letter, which creates a conflict between short arg names: from cliar import Cliar , set_help , set_metavars , set_arg_map , set_sharg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_sharg_map ({ 'n' : 'n' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' for _ in range ( n ): if shout : print ( greeting . upper ()) else : print ( greeting ) Now you can use -n instead of -r : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -n 2 Hello John! Hello John! To disable short argument variant entirely, set the short arg name to None : @set_sharg_map({'argname': None}) . More Commands \u00b6 Adding more commands to the CLI simply means adding more methods to the CLI class: class Greeter ( Cliar ): def goodbye ( self , name ): # Just define another method '''Say goodbye''' # to add another command to the CLI. print ( f 'Goodbye {name}!' ) @set_arg_map ({ 'n' : 'repeat' }) ... With this code addition, you can call goodbye command: $ python greeter.py goodbye Mary Goodbye Mary! Nested Commands \u00b6 You can have any level of nested commands by adding Cliar CLIs as class attributes. For example, let's add a utils subcommand with its own time subcommand that has now command: class Time ( Cliar ): def now ( self , utc = False ): if utc : print ( f 'UTC time is {datetime.utcnow().ctime()}' ) else : print ( f 'Local time is {datetime.now().ctime()}' ) class Utils ( Cliar ): time = Time class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' utils = Utils def _root ( self , version = False ): ... You can now call now command: $ python greeter.py utils time now Local time is Sun Jul 21 15 :25:52 2019 $ python greeter.py utils time now --utc UTC time is Sun Jul 21 11 :25:57 2019 Command Aliases \u00b6 Imagine you want to let user to call the same command with different keywords. For example, we want to ship our greeter app to Spain and let the users call greeter.py mientras as well as greeter.py goodbye . The keywords that point to the same command are called aliases . To add aliases to a command, use add_aliases decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases ... @add_aliases ([ 'mientras' , '\u043f\u043e\u043a\u0430' ]) # Yes you can use non-Latin characters! def goodbye ( self , name ): '''Say goodbye''' print ( f 'Goodbye {name}!' ) And now you can call goodbye command with its aliases: $ python greeter.py mientras Maria Goodbye Maria! $ python greeter.py \u043f\u043e\u043a\u0430 \u041c\u0430\u0448\u0430 Goodbye \u041c\u0430\u0448\u0430! Command Names \u00b6 By default, Cliar names CLI commands after the handler methods on the CLI class. To override this behavior and set a custom command name, use set_name decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' @set_name ( 'factorial' ) # Name the command `factorial` def calculate_factorial ( self , n : int ): # because `calculate_factorial` '''Calculate factorial''' # is too long for CLI. print ( f 'n! = {factorial(n)}' ) @add_aliases ([ 'mientras' , '\u043f\u043e\u043a\u0430' ]) ... Now calculate_factorial is associated with, and only with, factorial command: $ python greeter.py factorial 4 n! = 24 $ poetry run python greeter.py calculate_factorial 4 usage: greeter.py [ -h ] { factorial,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'calculate_factorial' ( choose from 'factorial' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' ) Ignore Methods \u00b6 By default, Cliar converts all non-static and non-class methods of the Cliar subclass into CLI commands. There are two ways to tell Cliar not to convert a method into a command: start its name with an underscore or use ignore decorator: from math import factorial , tau , pi from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name , ignore class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _get_tau_value ( self ): return tau @ignore def get_pi_value ( self ): return pi def constants ( self ): print ( f '\u03c4 = {self._get_tau_value()}' ) print ( f '\u03c0 = {self.get_pi_value()}' ) ... Only constants method will be exposed as a CLI command: $ poetry run python greeter.py constants \u03c4 = 6 .283185307179586 \u03c0 = 3 .141592653589793 $ poetry run python greeter.py get-pi-value usage: greeter.py [ -h ] { factorial,constants,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'get-pi-value' ( choose from 'factorial' , 'constants' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' ) Root Command \u00b6 So far, we've defined args and flags only for commands, e.g. hello and goodbye . But some flags are commonly defined for the entire script rather for a particular command, for example --version . Also, sometimes you don't need commands at all: if there's only only action that your CLI does, defining a single command is redundant as the script name will suffice: $ python say_hello.py # We want this $ python say_hello.py say_hello # rather than this. In other words, we need a way to define a nameless command that runs when you run the script itself without any command. Cliar lets you define such command by defining a special _root method: class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _root ( self , version = False ): if version : print ( 'Greeter 1.0.0.' ) else : print ( 'Welcome to Greeter!' ) ... If you run greeter.py with --version or -v flag, you'll see its version. If you call greeter.py without any flags or commands, you'll see a welcome message: $ python greeter.py Welcome to Greeter! $ python greeter.py --version Greeter 1 .0.0.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"Download the complete sample app: greeter.py","title":"Tutorial"},{"location":"tutorial/#hello-world","text":"In Cliar, commandline interfaces are represented by Python classes subclassed from Cliar . Cliar turns the class methods into commands and their params into args. Let's create a simple CLI that says \"Hello World!\" when you call hello command: from cliar import Cliar class Greeter ( Cliar ): # Define a regular Python class def hello ( self ): # and a regular method, print ( 'Hello World!' ) # which implements the business logic. if __name__ == '__main__' : Greeter () . parse () # Instantiate the class and run `parse` method. Save this code into greeter.py and run it with Python: $ python greeter.py hello Hello World! And here it is: your first CLI created with Cliar! That was easy, wasn't it?","title":"Hello World"},{"location":"tutorial/#optional-flags","text":"Let's enhance hello method to shout the greeting loud if --shout flag is passed: def hello ( self , shout = False ): greeting = 'Hello World!' if shout : print ( greeting . upper ()) else : print ( greeting ) Try running greeter.py with and without the newly defined flag: $ python greeter.py hello --shout HELLO WORLD! $ python greeter.py hello -s # Short version works, too! HELLO WORLD! $ python greeter.py hello Hello World! Cliar did a few things for us here: shout is an optional param, so it was converted into an optional flag since shout default value is False , Cliar inferred its type as bool , so we can use it as such inside hello body not only was --shout flag generated from the eponymous shout param, but a short version -s was also generated","title":"Optional Flags"},{"location":"tutorial/#positional-arguments","text":"Ok, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to hello : def hello ( self , name , shout = False ): greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) Try it: $ python greeter.py hello John Hello John! $ python greeter.py hello John --shout HELLO JOHN! $ python greeter.py hello -s John HELLO JOHN! $ python greeter.py hello usage: greeter.py hello [ -h ] [ -s ] name greeter.py hello: error: the following arguments are required: name","title":"Positional Arguments"},{"location":"tutorial/#help-messages","text":"If you run greeter.py with --help or -h flag, you'll see the help message generated by Cliar: $ python greeter.py --help usage: greeter.py [ -h ] { hello } ... optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello $ python greeter.py hello --help usage: greeter.py hello [ -h ] [ -s ] name positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout Although it does show some useful information, it's still quite poor: there's no app or command description or information about --shout or name arguments. First, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those: class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) Try calling the help messages now: $ python greeter.py -h usage: greeter.py [ -h ] { hello } ... Greeter app created with in Cliar. optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello Say hello to { name } . $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout That's much better! Now, let's add descriptions for --shout and name arguments. Hint self._parser is an ArgumentParser instance, so you can use all its methods and attributes, like print_help or usage .","title":"Help Messages"},{"location":"tutorial/#argument-descriptions","text":"To add description for arguments, use set_help decorator: from cliar import Cliar , set_help ... @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) The decorator takes a mapping from param names to help messages. Call the help message for hello command: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting To show default values for optional params, add show_defaults = True to set_help : ... @set_help ( { 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }, show_defaults = True ) def hello ( self , name , shout = False ): ... Call help again to see the default value: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting ( default: False )","title":"Argument Descriptions"},{"location":"tutorial/#metavars","text":"Metavar is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for name param the metavar is called name : $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting Let's change it to NAME , just so it's more visible in the line. To do that, use set_metavars decorator: from cliar import Cliar , set_help , set_metavars ... @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' if shout : print ( greeting . upper ()) else : print ( greeting ) The decorator takes a mapping from param names to metavars. Call the help message for hello : usage: greeter.py hello [ -h ] [ -s ] NAME Say hello. positional arguments: NAME The greetee optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting","title":"Metavars"},{"location":"tutorial/#type-casting","text":"Cliar can cast the types of args on the fly. To enable type casting, add a type hint to the param or set a default value for it. To showcase this feature, let's add a flag -n that will tell how many times we want the greeting to appear on the screen: @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' for _ in range ( n ): # Cliar guarantees `n` is an integer if shout : print ( greeting . upper ()) else : print ( greeting ) Note that inside hello code, we never convert n to integer or wrap anything in try blocks. Cliar cares about all that, allowing the programmer to focus on the business logic. Let's call hello with the new flag: $ python greeter.py hello John -n 2 Hello John! Hello John! Let's see what happens if we pass a non-integer value to -n : $ python greeter.py hello John -n foo usage: greeter.py hello [ -h ] [ -n N ] [ -s ] NAME greeter.py hello: error: argument -n/--n: invalid int value: 'foo' Because the passed value is invalid, Cliar stopped the execution before it even reached hello . This behavior guarantees that your code is always executed with valid input. Hint You can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using open as the param type: def read_from_file ( input_file : open ): lines = input_file . readlines () If you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed. Note If no type is set for a param, str is implied by default. So, name: str is the same as just name .","title":"Type Casting"},{"location":"tutorial/#argument-names","text":"By default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name: name is turned into --name , and upper_limit into --upper-limit ; the first letter is used as a short option: -n for --name , -u for --upper-limit . In the previous example, -n is a rather poor name for a flag. Something more descriptive, like --repeat would be better. Cliar lets you set the names of the args without changing the handler code at all. Just use set_arg_map decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' for _ in range ( n ): if shout : print ( greeting . upper ()) else : print ( greeting ) Now you can use --repeat or -r instead of -n : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -r 2 Hello John! Hello John! Hint This decorator lets you use Python's reserved words as arg names: --for , --with , etc. You can also override argument short names specifically. This is useful when you have several arguments that start with the same letter, which creates a conflict between short arg names: from cliar import Cliar , set_help , set_metavars , set_arg_map , set_sharg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_sharg_map ({ 'n' : 'n' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'The greetee' , 'shout' : 'Set to shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello {name}!' for _ in range ( n ): if shout : print ( greeting . upper ()) else : print ( greeting ) Now you can use -n instead of -r : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -n 2 Hello John! Hello John! To disable short argument variant entirely, set the short arg name to None : @set_sharg_map({'argname': None}) .","title":"Argument Names"},{"location":"tutorial/#more-commands","text":"Adding more commands to the CLI simply means adding more methods to the CLI class: class Greeter ( Cliar ): def goodbye ( self , name ): # Just define another method '''Say goodbye''' # to add another command to the CLI. print ( f 'Goodbye {name}!' ) @set_arg_map ({ 'n' : 'repeat' }) ... With this code addition, you can call goodbye command: $ python greeter.py goodbye Mary Goodbye Mary!","title":"More Commands"},{"location":"tutorial/#nested-commands","text":"You can have any level of nested commands by adding Cliar CLIs as class attributes. For example, let's add a utils subcommand with its own time subcommand that has now command: class Time ( Cliar ): def now ( self , utc = False ): if utc : print ( f 'UTC time is {datetime.utcnow().ctime()}' ) else : print ( f 'Local time is {datetime.now().ctime()}' ) class Utils ( Cliar ): time = Time class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' utils = Utils def _root ( self , version = False ): ... You can now call now command: $ python greeter.py utils time now Local time is Sun Jul 21 15 :25:52 2019 $ python greeter.py utils time now --utc UTC time is Sun Jul 21 11 :25:57 2019","title":"Nested Commands"},{"location":"tutorial/#command-aliases","text":"Imagine you want to let user to call the same command with different keywords. For example, we want to ship our greeter app to Spain and let the users call greeter.py mientras as well as greeter.py goodbye . The keywords that point to the same command are called aliases . To add aliases to a command, use add_aliases decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases ... @add_aliases ([ 'mientras' , '\u043f\u043e\u043a\u0430' ]) # Yes you can use non-Latin characters! def goodbye ( self , name ): '''Say goodbye''' print ( f 'Goodbye {name}!' ) And now you can call goodbye command with its aliases: $ python greeter.py mientras Maria Goodbye Maria! $ python greeter.py \u043f\u043e\u043a\u0430 \u041c\u0430\u0448\u0430 Goodbye \u041c\u0430\u0448\u0430!","title":"Command Aliases"},{"location":"tutorial/#command-names","text":"By default, Cliar names CLI commands after the handler methods on the CLI class. To override this behavior and set a custom command name, use set_name decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' @set_name ( 'factorial' ) # Name the command `factorial` def calculate_factorial ( self , n : int ): # because `calculate_factorial` '''Calculate factorial''' # is too long for CLI. print ( f 'n! = {factorial(n)}' ) @add_aliases ([ 'mientras' , '\u043f\u043e\u043a\u0430' ]) ... Now calculate_factorial is associated with, and only with, factorial command: $ python greeter.py factorial 4 n! = 24 $ poetry run python greeter.py calculate_factorial 4 usage: greeter.py [ -h ] { factorial,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'calculate_factorial' ( choose from 'factorial' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' )","title":"Command Names"},{"location":"tutorial/#ignore-methods","text":"By default, Cliar converts all non-static and non-class methods of the Cliar subclass into CLI commands. There are two ways to tell Cliar not to convert a method into a command: start its name with an underscore or use ignore decorator: from math import factorial , tau , pi from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name , ignore class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _get_tau_value ( self ): return tau @ignore def get_pi_value ( self ): return pi def constants ( self ): print ( f '\u03c4 = {self._get_tau_value()}' ) print ( f '\u03c0 = {self.get_pi_value()}' ) ... Only constants method will be exposed as a CLI command: $ poetry run python greeter.py constants \u03c4 = 6 .283185307179586 \u03c0 = 3 .141592653589793 $ poetry run python greeter.py get-pi-value usage: greeter.py [ -h ] { factorial,constants,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'get-pi-value' ( choose from 'factorial' , 'constants' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' )","title":"Ignore Methods"},{"location":"tutorial/#root-command","text":"So far, we've defined args and flags only for commands, e.g. hello and goodbye . But some flags are commonly defined for the entire script rather for a particular command, for example --version . Also, sometimes you don't need commands at all: if there's only only action that your CLI does, defining a single command is redundant as the script name will suffice: $ python say_hello.py # We want this $ python say_hello.py say_hello # rather than this. In other words, we need a way to define a nameless command that runs when you run the script itself without any command. Cliar lets you define such command by defining a special _root method: class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _root ( self , version = False ): if version : print ( 'Greeter 1.0.0.' ) else : print ( 'Welcome to Greeter!' ) ... If you run greeter.py with --version or -v flag, you'll see its version. If you call greeter.py without any flags or commands, you'll see a welcome message: $ python greeter.py Welcome to Greeter! $ python greeter.py --version Greeter 1 .0.0.","title":"Root Command"}]}