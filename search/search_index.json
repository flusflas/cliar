{
    "docs": [
        {
            "location": "/",
            "text": "Cliar\n\u00b6\n\n\nCliar is yet another Python package to create commandline interfaces. It focuses on simplicity, extensibility, and testability:\n\n\n\n\nCreating a CLI is as simple as subclassing \ncliar.Cliar\n.\n\n\nExtending a CLI is as simple as extending a class via inheritance.\n\n\nTesting a CLI is as simple as unittesting a class methods.\n\n\n\n\nCliar's mission is to let the programmer focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in the programmer's way, so it provides the means to customize the generated CLI.\n\n\nInstallation\n\u00b6\n\n\n$ pip install cliar\n\n\n\n\n\nCliar runs on Python 3.6+ on Windows, Linux, and Mac. There are no dependencies outside Python's standard library.\n\n\nComparison of Python CLI Packages\n\u00b6\n\n\n\n\n\n\n\n\nName\n\n\nDSL-based\n\n\nUses type hints\n\n\nExtensible\n\n\nTestable with unit tests\n\n\nHas pun in name\n\n\n\n\n\n\n\n\n\n\nClick\n\n\n\u274c\n\n\n\u274c\n\n\n\u2714, in third-party modules\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\ndocopt\n\n\n\u2714\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\n\n\n\nargparse\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\u274c\n\n\n\n\n\n\nCliar\n\n\n\u274c\n\n\n\u2714\n\n\n\u2714, in third-party modules \nand\n with third-party modules\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\n\n\nBasic Usage\n\u00b6\n\n\nLet's create a commandline calculator that adds two real numbers with Cliar:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n\n\n\n\nclass\n \nCalculator\n(\nCliar\n):\n\n\n'''Calculator app.'''\n\n\n\ndef\n \nadd\n(\nself\n,\n \nx\n:\n \nfloat\n,\n \ny\n:\n \nfloat\n):\n\n    \n'''Add two real numbers.'''\n\n\n    \nprint\n(\nf\n'The sum of {x} and {y} is {x+y}.'\n)\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nCalculator\n()\n.\nparse\n()\n\n\n\n\n\n\nSave this code to \ncalc.py\n and run it with different inputs:\n\n\n\n\n\n\nValid input:\n\n\n$ python run calc.py add \n12\n \n34\n\nThe sum of \n12\n.0 and \n34\n.0 is \n46\n.0.\n\n\n\n\n\n\n\n\n\nInvalid input:\n\n\n$ python run calc.py foo bar\nusage: calc.py add \n[\n-h\n]\n x y\ncalc.py add: error: argument x: invalid float value: \n'foo'\n\n\n\n\n\n\n\n\n\n\nGet help:\n\n\n$ python run calc.py -h\nusage: calc.py \n[\n-h\n]\n \n{\nadd\n}\n ...\n\nCalculator app.\n\noptional arguments:\n-h, --help  show this \nhelp\n message and \nexit\n\n\ncommands:\n\n{\nadd\n}\n       Available commands:\n    add       Add two real numbers.\n\n\n\n\n\n\n\n\n\nGet help for a specific command:\n\n\n$ python calc.py add -h\nusage: calc.py add \n[\n-h\n]\n x y\n\nAdd two real numbers.\n\npositional arguments:\nx\ny\n\noptional arguments:\n-h, --help  show this \nhelp\n message and \nexit\n\n\n\n\n\n\n\n\n\n\nThere are a few things to note here:\n\n\n\n\n\n\nIt's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar.\n\n\n\n\n\n\nThe \nadd\n method is converted into \nadd\n command, and its positional params are converted into positional commandline args.\n\n\n\n\n\n\nWe don't convert \nx\n or \ny\n to \nfloat\n or handle any potential conversion errors in the \nadd\n body. Instead, we treat \nx\n and \ny\n as if they were already guaranteed to be floats. That's because Cliar does the validation and conversion for us, using the information from \nadd\n's type hints. Note how invalid input doesn't even reach your code.\n\n\n\n\n\n\nThe \n--help\n and \n-h\n flags are added automatically and the help messages are generated from the docstrings.\n\n\n\n\n\n\nBut wait! There's more!\n\u00b6\n\n\nCliar lets you customize your CLI in many ways! \nRead the tutorial\n to learn all Cliar's powers.\n\n\nHappy hacking!",
            "title": "Home"
        },
        {
            "location": "/#cliar",
            "text": "Cliar is yet another Python package to create commandline interfaces. It focuses on simplicity, extensibility, and testability:   Creating a CLI is as simple as subclassing  cliar.Cliar .  Extending a CLI is as simple as extending a class via inheritance.  Testing a CLI is as simple as unittesting a class methods.   Cliar's mission is to let the programmer focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in the programmer's way, so it provides the means to customize the generated CLI.",
            "title": "Cliar"
        },
        {
            "location": "/#installation",
            "text": "$ pip install cliar  Cliar runs on Python 3.6+ on Windows, Linux, and Mac. There are no dependencies outside Python's standard library.",
            "title": "Installation"
        },
        {
            "location": "/#comparison-of-python-cli-packages",
            "text": "Name  DSL-based  Uses type hints  Extensible  Testable with unit tests  Has pun in name      Click  \u274c  \u274c  \u2714, in third-party modules  \u2714  \u2714    docopt  \u2714  \u274c  \u274c  \u274c  \u274c    argparse  \u274c  \u274c  \u274c  \u274c  \u274c    Cliar  \u274c  \u2714  \u2714, in third-party modules  and  with third-party modules  \u2714  \u2714",
            "title": "Comparison of Python CLI Packages"
        },
        {
            "location": "/#basic-usage",
            "text": "Let's create a commandline calculator that adds two real numbers with Cliar:  from   cliar   import   Cliar  class   Calculator ( Cliar ):  '''Calculator app.'''  def   add ( self ,   x :   float ,   y :   float ): \n     '''Add two real numbers.''' \n\n     print ( f 'The sum of {x} and {y} is {x+y}.' )  if   __name__   ==   '__main__' : \n     Calculator () . parse ()   Save this code to  calc.py  and run it with different inputs:    Valid input:  $ python run calc.py add  12   34 \nThe sum of  12 .0 and  34 .0 is  46 .0.    Invalid input:  $ python run calc.py foo bar\nusage: calc.py add  [ -h ]  x y\ncalc.py add: error: argument x: invalid float value:  'foo'     Get help:  $ python run calc.py -h\nusage: calc.py  [ -h ]   { add }  ...\n\nCalculator app.\n\noptional arguments:\n-h, --help  show this  help  message and  exit \n\ncommands: { add }        Available commands:\n    add       Add two real numbers.    Get help for a specific command:  $ python calc.py add -h\nusage: calc.py add  [ -h ]  x y\n\nAdd two real numbers.\n\npositional arguments:\nx\ny\n\noptional arguments:\n-h, --help  show this  help  message and  exit     There are a few things to note here:    It's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar.    The  add  method is converted into  add  command, and its positional params are converted into positional commandline args.    We don't convert  x  or  y  to  float  or handle any potential conversion errors in the  add  body. Instead, we treat  x  and  y  as if they were already guaranteed to be floats. That's because Cliar does the validation and conversion for us, using the information from  add 's type hints. Note how invalid input doesn't even reach your code.    The  --help  and  -h  flags are added automatically and the help messages are generated from the docstrings.",
            "title": "Basic Usage"
        },
        {
            "location": "/#but-wait-theres-more",
            "text": "Cliar lets you customize your CLI in many ways!  Read the tutorial  to learn all Cliar's powers.  Happy hacking!",
            "title": "But wait! There's more!"
        },
        {
            "location": "/tutorial/",
            "text": "Tutorial\n\u00b6\n\n\nHello World\n\u00b6\n\n\nIn Cliar, commandline interface is represented with a Python class subclassed from \nCliar\n. Cliar turns the class methods into commands and their params into args.\n\n\nLet's create the simplest CLI that says \"Hello World!\" when you call \"hello\" command:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n\n\n\n\nclass\n \nGreeter\n(\nCliar\n):\n           \n# Define a regular Python class\n\n    \ndef\n \nhello\n(\nself\n):\n            \n# and a regular method,\n\n        \nprint\n(\n'Hello World!'\n)\n   \n# which implements the business logic.\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \ngreeter\n \n=\n \nGreeter\n()\n         \n# Create an instance of the class\n\n    \ngreeter\n.\nparse\n()\n             \n# and run its `parse` method.\n\n\n\n\n\n\nSave this code into \ngreeter.py\n and run it with Python:\n\n\n$ python greeter.py hello\nHello World!\n\n\n\n\n\nAnd here it is: your first CLI created with Cliar! That was easy, wasn't it?\n\n\nLet's extend \nhello\n method to shout the greeting if \n--shout\n flag is passed:\n\n\n    \ndef\n \nhello\n(\nself\n,\n \nshout\n=\nFalse\n):\n\n        \ngreeting\n \n=\n \n'Hello World!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nTry running \ngreeter.py\n with and without the newly defined flag:\n\n\n$ python greeter.py hello --shout\nHELLO WORLD!\n$ python greeter.py hello -s    \n# Short version works, too!\n\nHELLO WORLD!\n$ python greeter.py hello\nHello World!\n\n\n\n\n\nCliar did a few things for us here:\n\n\n\n\nshout\n is an optional param, so it was converted into an optional flag\n\n\nsince \nshout\n default value is \nFalse\n, Cliar inferred its type as \nbool\n, so we can use it as such inside \nhello\n body\n\n\nnot only was \n--shout\n flag generated from the eponymous \nshout\n param, but a short version \n-s\n was also generated\n\n\n\n\nHello {user}\n\u00b6\n\n\nOk, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to \nhello\n:\n\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nTry it:\n\n\n$ python greeter.py hello John\nHello John!\n$ python greeter.py hello John --shout\nHELLO JOHN!\n$ python greeter.py hello -s John\nHELLO JOHN!\n$ python greeter.py hello\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\ngreeter.py hello: error: the following arguments are required: name\n\n\n\n\n\nHelp Messages\n\u00b6\n\n\nIf you run \ngreeter.py\n with \n--help\n or \n-h\n flag, you'll see the help message generated by Cliar:\n\n\n$ python greeter.py --help\nusage: greeter.py \n[\n-h\n]\n \n{\nhello\n}\n ...\n\noptional arguments:\n  -h, --help  show this \nhelp\n message and \nexit\n\n\ncommands:\n  \n{\nhello\n}\n     Available commands:\n    hello\n\n$ python greeter.py hello --help\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout\n\n\n\n\n\nAlthough it does show some useful information, it's still quite poor: there's no app or command description or information about \n--shout\n or \nname\n arguments.\n\n\nFirst, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those:\n\n\nclass\n \nGreeter\n(\nCliar\n):\n\n    \n'''Greeter app created with in Cliar.'''\n\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nTry calling the help messages now:\n\n\n$ python greeter.py -h\nusage: greeter.py \n[\n-h\n]\n \n{\nhello\n}\n ...\n\nGreeter app created with in Cliar.\n\noptional arguments:\n  -h, --help  show this \nhelp\n message and \nexit\n\n\ncommands:\n  \n{\nhello\n}\n     Available commands:\n    hello     Say hello to \n{\nname\n}\n.\n\n$ python greeter.py hello -h\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\nSay hello.\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout\n\n\n\n\n\nThat's much better! Now, let's add descriptions for \n--shout\n and \nname\n arguments.\n\n\nArgument Descriptions\n\u00b6\n\n\nTo add description for arguments, use \nset_help\n decorator:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n\n\n\n...\n\n\n    \n@set_help\n({\n'name'\n:\n \n'The greetee'\n,\n \n'shout'\n:\n \n'Set to shout the greeting'\n})\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nThe decorator takes a mapping from param names to help messages.\n\n\nCall the help message for \nhello\n command:\n\n\n$ python greeter.py hello -h\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout  Set to shout the greeting\n\n\n\n\n\nMetavars\n\u00b6\n\n\nMetavar\n is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for \nname\n param the metavar is called \nname\n:\n\n\n$ python greeter.py hello -h\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout  Set to shout the greeting\n\n\n\n\n\nLet's change it to \nNAME\n, just so it's more visible in the line. To do that, use \nset_metavars\n decorator:\n\n\nfrom\n \ncliar\n \nimport\n \nCliar\n,\n \nset_help\n,\n \nset_metavars\n\n\n\n...\n\n\n    \n@set_metavars\n({\n'name'\n:\n \n'NAME'\n})\n\n    \n@set_help\n({\n'name'\n:\n \n'The greetee'\n,\n \n'shout'\n:\n \n'Set to shout the greeting'\n})\n\n    \ndef\n \nhello\n(\nself\n,\n \nname\n,\n \nshout\n=\nFalse\n):\n\n        \n'''Say hello.'''\n\n\n        \ngreeting\n \n=\n \nf\n'Hello {name}!'\n\n\n        \nif\n \nshout\n:\n\n            \nprint\n(\ngreeting\n.\nupper\n())\n\n        \nelse\n:\n\n            \nprint\n(\ngreeting\n)\n\n\n\n\n\n\nThe decorator takes a mapping from param names to metavars.\n\n\nCall the help message for \nhello\n:\n\n\nusage: greeter.py hello \n[\n-h\n]\n \n[\n-s\n]\n NAME\n\nSay hello.\n\npositional arguments:\n  NAME         The greetee\n\noptional arguments:\n  -h, --help   show this \nhelp\n message and \nexit\n\n  -s, --shout  Set to shout the greeting",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#tutorial",
            "text": "",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#hello-world",
            "text": "In Cliar, commandline interface is represented with a Python class subclassed from  Cliar . Cliar turns the class methods into commands and their params into args.  Let's create the simplest CLI that says \"Hello World!\" when you call \"hello\" command:  from   cliar   import   Cliar  class   Greeter ( Cliar ):             # Define a regular Python class \n     def   hello ( self ):              # and a regular method, \n         print ( 'Hello World!' )     # which implements the business logic.  if   __name__   ==   '__main__' : \n     greeter   =   Greeter ()           # Create an instance of the class \n     greeter . parse ()               # and run its `parse` method.   Save this code into  greeter.py  and run it with Python:  $ python greeter.py hello\nHello World!  And here it is: your first CLI created with Cliar! That was easy, wasn't it?  Let's extend  hello  method to shout the greeting if  --shout  flag is passed:       def   hello ( self ,   shout = False ): \n         greeting   =   'Hello World!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   Try running  greeter.py  with and without the newly defined flag:  $ python greeter.py hello --shout\nHELLO WORLD!\n$ python greeter.py hello -s     # Short version works, too! \nHELLO WORLD!\n$ python greeter.py hello\nHello World!  Cliar did a few things for us here:   shout  is an optional param, so it was converted into an optional flag  since  shout  default value is  False , Cliar inferred its type as  bool , so we can use it as such inside  hello  body  not only was  --shout  flag generated from the eponymous  shout  param, but a short version  -s  was also generated",
            "title": "Hello World"
        },
        {
            "location": "/tutorial/#hello-user",
            "text": "Ok, but what if we want our app to be able to greet anyone, not just the world? Just add a positional param to  hello :       def   hello ( self ,   name ,   shout = False ): \n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   Try it:  $ python greeter.py hello John\nHello John!\n$ python greeter.py hello John --shout\nHELLO JOHN!\n$ python greeter.py hello -s John\nHELLO JOHN!\n$ python greeter.py hello\nusage: greeter.py hello  [ -h ]   [ -s ]  name\ngreeter.py hello: error: the following arguments are required: name",
            "title": "Hello {user}"
        },
        {
            "location": "/tutorial/#help-messages",
            "text": "If you run  greeter.py  with  --help  or  -h  flag, you'll see the help message generated by Cliar:  $ python greeter.py --help\nusage: greeter.py  [ -h ]   { hello }  ...\n\noptional arguments:\n  -h, --help  show this  help  message and  exit \n\ncommands:\n   { hello }      Available commands:\n    hello\n\n$ python greeter.py hello --help\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Although it does show some useful information, it's still quite poor: there's no app or command description or information about  --shout  or  name  arguments.  First, let's add app and command descriptions. Cliar uses class and method docstrings to generate help messages, so just add those:  class   Greeter ( Cliar ): \n     '''Greeter app created with in Cliar.''' \n\n     def   hello ( self ,   name ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   Try calling the help messages now:  $ python greeter.py -h\nusage: greeter.py  [ -h ]   { hello }  ...\n\nGreeter app created with in Cliar.\n\noptional arguments:\n  -h, --help  show this  help  message and  exit \n\ncommands:\n   { hello }      Available commands:\n    hello     Say hello to  { name } .\n\n$ python greeter.py hello -h\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\nSay hello.\n\npositional arguments:\n  name\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  That's much better! Now, let's add descriptions for  --shout  and  name  arguments.",
            "title": "Help Messages"
        },
        {
            "location": "/tutorial/#argument-descriptions",
            "text": "To add description for arguments, use  set_help  decorator:  from   cliar   import   Cliar ,   set_help  ... \n\n     @set_help ({ 'name' :   'The greetee' ,   'shout' :   'Set to shout the greeting' }) \n     def   hello ( self ,   name ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   The decorator takes a mapping from param names to help messages.  Call the help message for  hello  command:  $ python greeter.py hello -h\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Set to shout the greeting",
            "title": "Argument Descriptions"
        },
        {
            "location": "/tutorial/#metavars",
            "text": "Metavar  is the placeholder of a positional arg as it appears in the usage message. By default, Cliar uses the param name as its metavar. So, for  name  param the metavar is called  name :  $ python greeter.py hello -h\nusage: greeter.py hello  [ -h ]   [ -s ]  name\n\nSay hello.\n\npositional arguments:\n  name         The greetee\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Set to shout the greeting  Let's change it to  NAME , just so it's more visible in the line. To do that, use  set_metavars  decorator:  from   cliar   import   Cliar ,   set_help ,   set_metavars  ... \n\n     @set_metavars ({ 'name' :   'NAME' }) \n     @set_help ({ 'name' :   'The greetee' ,   'shout' :   'Set to shout the greeting' }) \n     def   hello ( self ,   name ,   shout = False ): \n         '''Say hello.''' \n\n         greeting   =   f 'Hello {name}!' \n\n         if   shout : \n             print ( greeting . upper ()) \n         else : \n             print ( greeting )   The decorator takes a mapping from param names to metavars.  Call the help message for  hello :  usage: greeter.py hello  [ -h ]   [ -s ]  NAME\n\nSay hello.\n\npositional arguments:\n  NAME         The greetee\n\noptional arguments:\n  -h, --help   show this  help  message and  exit \n  -s, --shout  Set to shout the greeting",
            "title": "Metavars"
        },
        {
            "location": "/changelog/",
            "text": "Changelog\n\u00b6\n\n\n1.2.2\n\u00b6\n\n\n\n\nMake \n_root\n not an abstract method.\n\n\n\n\n1.2.1\n\u00b6\n\n\n\n\nFix critical bug that disallowed string params.\n\n\n\n\n1.2.0\n\u00b6\n\n\n\n\nBoolean handler params are converted into \nstore_true\n arguments. Before that, params with default value of \nTrue\n were much confusingly converted into \nstore_false\n arguments.\n\n\nSupport \nList[int]\n and similar arg types. If the param type is a subclass of \ntyping.Iterable\n and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets.\n\n\nDo not print help whenever \n_root\n command is invoked.\n\n\nConvert the \ncliar\n module into a package.\n\n\nAdd tests.\n\n\nSwitch to Poetry.\n\n\n\n\n1.1.9\n\u00b6\n\n\n\n\nAdd the ability to set help messages for arguments.\n\n\nAdd the ability to set metavars for arguments.\n\n\n\n\n1.1.8\n\u00b6\n\n\n\n\n[Breaks backward compatibility]\n Base CLI class renamed from \nCLI\n to \nCliar\n.\n\n\nFixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.\n\n\n\n\n1.1.7\n\u00b6\n\n\n\n\nAdd the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.\n\n\n\n\n1.1.6\n\u00b6\n\n\n\n\nUnderscores in handler names are now replaced with dashes when the corresponding command name is generated.\n\n\n\n\n1.1.5\n\u00b6\n\n\n\n\nOptional arguments are now prepended with '--', not '-'.\n\n\nShort argument names are now generated from the long ones: \nname\n handler arg corresponds to \n-n\n and \n--name\n commandline args.\n\n\nPython 2 support dropped. Python 3.5+ required.\n\n\nCode refactored, type hints added.\n\n\n\n\n1.1.4\n\u00b6\n\n\n\n\nCode improvements for API documentation.\n\n\n\n\n1.1.3\n\u00b6\n\n\n\n\nCode cleanup.\n\n\n\n\n1.1.2\n\u00b6\n\n\n\n\nSetup: Python version check improved.\n\n\n\n\n1.1.1\n\u00b6\n\n\n\n\nPython 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed.\n\n\nIf only the _root handler is defined, the commands subparser is not added anymore.\n\n\nPackaging improved, the installation package now includes both Python 2 and 3 sources.\n\n\n\n\n1.1.0\n\u00b6\n\n\n\n\nCommand descriptions did not preserve line breaks from docstrings. Fixed.\n\n\n\n\n1.0.9\n\u00b6\n\n\n\n\nCommands now use the first docstring line as help and the whole docstring as description.\n\n\n\n\n1.0.8\n\u00b6\n\n\n\n\nDescription and help texts now preserve line breaks from docstrings.\n\n\n\n\n1.0.7\n\u00b6\n\n\n\n\nSupport of multiple values for a single arg added.\n\n\n\n\n1.0.6\n\u00b6\n\n\n\n\nCommand-line args are now parsed by explicitly calling the \n.parse()\n method.\n\n\n\n\n1.0.5\n\u00b6\n\n\n\n\nThe \nignore\n decorator added to exclude a method from being converted into a command.\n\n\n\n\n1.0.4\n\u00b6\n\n\n\n\nNested CLI methods would not override parent methods. Fixed.\n\n\n\n\n1.0.3\n\u00b6\n\n\n\n\nPython 2 support added.\n\n\n\n\n1.0.2\n\u00b6\n\n\n\n\nDocstring added to the add_aliases function.\n\n\nThe set_name function is now less hacky.\n\n\n\n\n1.0.1\n\u00b6\n\n\n\n\nAlias support added with the \"add_aliases\" decorator.\n\n\n\n\n1.0.0\n\u00b6\n\n\n\n\nFirst version. Changelog started.",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#changelog",
            "text": "",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#122",
            "text": "Make  _root  not an abstract method.",
            "title": "1.2.2"
        },
        {
            "location": "/changelog/#121",
            "text": "Fix critical bug that disallowed string params.",
            "title": "1.2.1"
        },
        {
            "location": "/changelog/#120",
            "text": "Boolean handler params are converted into  store_true  arguments. Before that, params with default value of  True  were much confusingly converted into  store_false  arguments.  Support  List[int]  and similar arg types. If the param type is a subclass of  typing.Iterable  and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets.  Do not print help whenever  _root  command is invoked.  Convert the  cliar  module into a package.  Add tests.  Switch to Poetry.",
            "title": "1.2.0"
        },
        {
            "location": "/changelog/#119",
            "text": "Add the ability to set help messages for arguments.  Add the ability to set metavars for arguments.",
            "title": "1.1.9"
        },
        {
            "location": "/changelog/#118",
            "text": "[Breaks backward compatibility]  Base CLI class renamed from  CLI  to  Cliar .  Fixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.",
            "title": "1.1.8"
        },
        {
            "location": "/changelog/#117",
            "text": "Add the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.",
            "title": "1.1.7"
        },
        {
            "location": "/changelog/#116",
            "text": "Underscores in handler names are now replaced with dashes when the corresponding command name is generated.",
            "title": "1.1.6"
        },
        {
            "location": "/changelog/#115",
            "text": "Optional arguments are now prepended with '--', not '-'.  Short argument names are now generated from the long ones:  name  handler arg corresponds to  -n  and  --name  commandline args.  Python 2 support dropped. Python 3.5+ required.  Code refactored, type hints added.",
            "title": "1.1.5"
        },
        {
            "location": "/changelog/#114",
            "text": "Code improvements for API documentation.",
            "title": "1.1.4"
        },
        {
            "location": "/changelog/#113",
            "text": "Code cleanup.",
            "title": "1.1.3"
        },
        {
            "location": "/changelog/#112",
            "text": "Setup: Python version check improved.",
            "title": "1.1.2"
        },
        {
            "location": "/changelog/#111",
            "text": "Python 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed.  If only the _root handler is defined, the commands subparser is not added anymore.  Packaging improved, the installation package now includes both Python 2 and 3 sources.",
            "title": "1.1.1"
        },
        {
            "location": "/changelog/#110",
            "text": "Command descriptions did not preserve line breaks from docstrings. Fixed.",
            "title": "1.1.0"
        },
        {
            "location": "/changelog/#109",
            "text": "Commands now use the first docstring line as help and the whole docstring as description.",
            "title": "1.0.9"
        },
        {
            "location": "/changelog/#108",
            "text": "Description and help texts now preserve line breaks from docstrings.",
            "title": "1.0.8"
        },
        {
            "location": "/changelog/#107",
            "text": "Support of multiple values for a single arg added.",
            "title": "1.0.7"
        },
        {
            "location": "/changelog/#106",
            "text": "Command-line args are now parsed by explicitly calling the  .parse()  method.",
            "title": "1.0.6"
        },
        {
            "location": "/changelog/#105",
            "text": "The  ignore  decorator added to exclude a method from being converted into a command.",
            "title": "1.0.5"
        },
        {
            "location": "/changelog/#104",
            "text": "Nested CLI methods would not override parent methods. Fixed.",
            "title": "1.0.4"
        },
        {
            "location": "/changelog/#103",
            "text": "Python 2 support added.",
            "title": "1.0.3"
        },
        {
            "location": "/changelog/#102",
            "text": "Docstring added to the add_aliases function.  The set_name function is now less hacky.",
            "title": "1.0.2"
        },
        {
            "location": "/changelog/#101",
            "text": "Alias support added with the \"add_aliases\" decorator.",
            "title": "1.0.1"
        },
        {
            "location": "/changelog/#100",
            "text": "First version. Changelog started.",
            "title": "1.0.0"
        }
    ]
}